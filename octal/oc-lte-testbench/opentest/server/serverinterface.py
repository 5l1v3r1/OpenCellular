
import threading
import requests
import sys
import logging
import click

import base
from base import GenericRequest, GenericServer
from service.base import ServiceClient, ServiceFactory, ServiceError
from nute import utils
from jsonutils import *

class ServerInterface(object):
    def __init__(self, addr, port, name='server'):
        self.addr = addr
        self.port = port
        self.name = name
        self.full_url = "http://%s:%s" % (addr, str(port))
        self.factory = ServiceFactory()
        self.services = {}

    def config_request(self, content):
        return self._post_at_url('config', content)

    def set_log_destination(self, destination):
        content = utils.EmptyObject()
        setattr(content, GenericServer.CONFIG_LOG_DESTINATION, destination)
        self.config_request(content)

    def new_client_at_url(self, client_name, url):
        return self.factory.new_service_client(url=url, port=self.port, ip=self.addr, class_name=client_name)

    def open_logs_request(self):
        return self._post_at_url('openlogs', None)

    def shutdown_request(self, move_logs=""):
        content = GenericRequest()
        if move_logs != "" and move_logs != None:
            content.move_logs = move_logs

        return self._post_at_url('shutdown', content)

    def shell_request(self, url, msg):
        client = ServiceClient(url=url, ip=self.addr, port=self.port)
        return client.shell(msg)

    def kill_if_alive(self):
        if not self.is_alive():
            return
        #Alive if we get here
        self.shutdown_request()

    def is_alive(self):
       alive = True
       try:
           self.assert_alive(retries=0)
       except:
           alive = False
       return alive

    def assert_alive(self, retries=10, timeout=2):
        while retries >= 0:
            retries = retries - 1
            try:
                resp = requests.get(self.full_url, timeout = timeout)
                assert resp.status_code < 400
                break
            except:
                continue
        else:
            #Reached end of retries
            assert retries >= 0, "Server is not alive"

    def _post_at_url(self, url, content):
        return requests.post(self._get_url(url), object_to_json(content))

    def _get_url(self, sub_path):
        return "%s/%s" % (self.full_url, sub_path)

    def create_service(self, client_name, url, client_class_name, service_class_name):
        reservation_client = ServiceClient(url="", ip=self.ADDR, port=self.PORT)
        config = {'url': None, 'uuid': None, 'reservation': True}
        config['url'] = url
        config['uuid'] = service_class_name
        #Reserve the url to this service uuid
        self.logger.debug("Client %s (%s -> %s@%s)" % (client_name, client_class_name, service_class_name, url))
        reservation_client.new_service(**config)
        requested_client = self.get_service_client_from_name(client_class_name, url)
        requested_client.set_logger(self.logger)
        self.add_client(client_name, requested_client)


    def add_client(self, name, client):
        setattr(self, name, client)
        self.services[name] = client

    def get_service_client_from_name(self, class_name, url):
        return self.factory.new_service_client(class_name, url, self.PORT, ip=self.ADDR)

class LaunchedServerInterface(ServerInterface):
    """
    This handles the creation of the server and an ini file. The actual server launch
    must be implemented by a child class.
    The ini file loads the arguments to the creation if present (port, name, addr)
    The ini file reserves services and creates service clients as attributes to this
    object.
    """
    def __init__(self, addr='127.0.0.1', port=5000, name='LaunchedServerInterface', ini_file=None, logger=None):
        #defaults
        if logger is None:
            self.logger = logging.getLogger()
        else:
            self.logger = logger

        self.ADDR = addr
        self.PORT = port
        self.NAME = name
        self.server_ini = utils.EmptyObject()

        #Overwrite with ini file if possible
        if ini_file is not None:
            self.load_init_file(ini_file)

        ServerInterface.__init__(self, self.ADDR, self.PORT, name=self.NAME)
        self.factory.logger = self.logger

        self.launch_server(self.ADDR, self.PORT, self.NAME)

        if ini_file is not None:
            self.reserve_services_and_create_clients(self.server_ini)

        self.logger.info("%s launched at %s:%d" %(self.NAME, self.ADDR, self.PORT))

    def launch_server(self, addr, port, name):
        raise NotImplementedError("Function launch_server is not implemented")

    def load_init_file(self, ini_file):
        utils.load_ini_in_obj(ini_file, self.server_ini)
        self.add_server_attributes_to_self(self.server_ini)

    def add_server_attributes_to_self(self, obj):
        #All attributes in section SERVER are added to this instance
        for server_attr_name, server_attr_value in obj.get_as_dict('SERVER').iteritems():
            setattr(self, server_attr_name, server_attr_value)

    def reserve_services_and_create_clients(self, obj):

        for service_attr_name, service_config in obj.get_as_dict('SERVICE').iteritems():
            # Format is a tuple: (<url>, <ServiceName>, <ServiceClientName>)
            url = service_config[0]
            service_class_name = service_config[1]
            client_class_name = service_config[2]
            self.create_service(service_attr_name, url, client_class_name, service_class_name)



class LocalLaunchedServerInterface(LaunchedServerInterface):
    def __init__(self, *args, **kwargs):
        #Use local addr
        LaunchedServerInterface.__init__(self, addr='127.0.0.1', *args, **kwargs)

    #Override
    def launch_server(self, addr, port, name):
        import server_main
        server_main.launch(port, name)



def standalone_server_gui(serverurl, serverport):
    root = tk.Tk()
    gui = ServerGUI(root)
    gui.set_server_interface(ServerInterface(serverurl, serverport))
    gui.pack()
    gui.start()

def standalone_server_cli(serverurl, serverport):
    cli = ServerCLI(ServerInterface(serverurl, serverport))
    cli.start()

# class ServerGUI(tk.Frame):
#
#     def __init__(self, parent, *args, **kwargs):
#         tk.Frame.__init__(self, parent, *args, **kwargs)
#         self.parent = parent
#         self.runner_thread = None
#         self.url = ""
#
#         logs_button = tk.Button(self.parent, text ="Open logs", command = self.open_logs_button)
#         logs_button.pack()
#
#         shutdown_button = tk.Button(self.parent, text ="Shutdown", command = self.shutdown_button)
#         shutdown_button.pack()
#
#     def open_logs_button(self):
#         self.server.open_logs_request()
#
#     def shutdown_button(self):
#         self.server.shutdown_request()
#
#     def set_server_interface(self, interface):
#         self.server = interface
#
#     def start(self):
#         main_thread = threading.Thread(target=self.parent.mainloop)
#         main_thread.setDaemon(True)
#         main_thread.start()

class ServerCLI():


    def __init__(self, interface):
        self.url = None
        self.server_interface = interface
        self._service_shell_url = ""
        self.main_thread = None
        self.exec_env = {}

    def start(self):
        self.main_thread = threading.Thread(target=self.read_thread)
        self.main_thread.setDaemon(True)
        self.main_thread.start()

    def join(self):
        if self.main_thread is not None:
            while True:
                self.main_thread.join(100)

    def read_thread(self):
        state_fn = self.top_level_shell

        while True:
            try:
                string = raw_input()
                state_fn = state_fn(string)
            except EOFError:
                break

    def top_level_shell(self, string):
        COMMANDS = {
        'openlogs': ServerCLI.cmd_openlogs,
        'shell' : ServerCLI.cmd_shell,
        'shutdown': ServerCLI.cmd_shutdown,
        'exec': ServerCLI.cmd_exec
        }
        strings = string.strip().split(' ')
        if len(strings) > 0:
            if strings[0] in COMMANDS:
                fn = COMMANDS[strings[0]](self, strings)
                if fn:
                    return fn
        sys.stdout.write(self.shell_name())
        sys.stdout.flush()
        return self.top_level_shell

    def cmd_openlogs(self, args):
        self.server_interface.open_logs_request()

    def cmd_shell(self, args):
        if len(args) > 1:
            self._service_shell_url = args[1]
            print("Use '.' to exit this service's shell.")
            return self.service_shell('')
        else:
            print("Usage: shell <service_url>")

    def cmd_exec(self, args):
        print("Use '.' to exit exec environment.")
        return self.exec_shell(' '.join(args[1:]))

    def cmd_shutdown(self, args):
        move_logs = ""
        if len(args) > 1:
            move_logs = args[1]
        else:
            print("Usage: shutdown <destination folder for logs>. Shutdown initiated without log move.")


    def shell_name(self, sub_shell=[]):
        shells = [self.server_interface.name] + sub_shell
        return '%s>' % '.'.join(shells)

    def service_shell(self, string):
        string = string + '\n'

        stripped_str = string.strip()
        if stripped_str == '.':
            return self.top_level_shell('\n')
        else:
            try:
                self.server_interface.shell_request(url=self._service_shell_url, msg=string)
            except ServiceError as e:
                print(str(e))
                return self.top_level_shell('\n')
        sys.stdout.write(self.shell_name([self._service_shell_url]))
        sys.stdout.flush()
        return self.service_shell

    def exec_shell(self, string):
        stripped_str = string.strip()
        if stripped_str == '.':
            return self.top_level_shell('\n')

        server = self.server_interface
        temp_locals = locals().copy()
        temp_locals.update(self.exec_env)
        try:
            try:
                if string:
                    exec("print(%s)" % string, globals(), temp_locals)
            except:
                exec(string, globals(), temp_locals)
        except:
            import traceback
            traceback.print_exc()
        self.exec_env = temp_locals
        sys.stdout.write('exec>>>')
        sys.stdout.flush()
        return self.exec_shell
