import logging
import os
import __builtin__
import serverconst
import __init__

server_logger = logging.getLogger(serverconst.SERVER_LOGGER_NAME)
server_logger.addHandler(logging.NullHandler())

from jsonutils import *
import service
from service.base import *
import traceback
import datetime
from opentest.log import multipletail

def std_server_name(name, port):
    return name + "@" + str(port)

def server_init(name, port):
    global server_logger
    __builtin__.SERVER_NAME = name
    __builtin__.SERVER_PORT = int(port)

    path = os.path.dirname(os.path.realpath(__file__))

    path = os.path.join(path, 'instances')
    if not os.path.isdir(path):
        os.mkdir(path)

    path = os.path.join(path, std_server_name(name, port))
    if not os.path.isdir(path):
        os.mkdir(path)

    __builtin__.SERVER_FILES_PATH = path


    # create console handler and set level to debug
    ch = logging.StreamHandler()
    ch.setLevel(logging.WARNING)

    fh = logging.FileHandler(os.path.join(path, 'server.log'))
    fh.setLevel(logging.INFO)
    # create formatter

    file_formatter = logging.Formatter('%(asctime)s: %(name)-50s: %(levelname)-8s%(message)s')
    stream_formatter = logging.Formatter('%(relativeCreated)d:%(name)s: %(levelname)-8s%(message)s')

    # add formatter to ch
    ch.setFormatter(stream_formatter)
    fh.setFormatter(file_formatter)

    # add ch to logger
    server_logger.addHandler(ch)
    server_logger.addHandler(fh)
    server_logger.setLevel(logging.DEBUG)

    '''FLASK IMPLEMENTATION'''
    from flaskimpl import FlaskServer
    server = FlaskServer(__builtin__.SERVER_NAME, __builtin__.SERVER_PORT)
    server_logger.info("\n\n")
    server_logger.info("SERVER INITIALIZED")
    return server



class NewServiceRequest():
    def __init__(self):
        self.uuid = None
        self.override_url = None
        self.file_log = True

class GenericRequest():
    pass

class GenericResponse():
    def __init__(self, status_code=200, body=None, message=None):
        self.status_code=status_code
        self.body = None
        if body is not None:
            self.body = body
        elif message is not None:
            self.body = GenericResponseBody(message=message)

class ErrorResponse(GenericResponse):
    def __init__(self, status_code=500, message="No message", error=None):
        self.status_code=status_code
        self.body = GenericResponseBody(message = message)
        if error is not None:
            import traceback
            self.body.exception_type=str(type(error).__name__)
            self.body.exception_message = str(error)
            self.body.format_exc = traceback.format_exc()
        else:
            self.body.exception_type=str(None)

class StreamResponse(GenericResponse):
    def __init__(self, status_code=200, body=None):
        self.status_code=status_code
        self.body = body

class GenericResponseBody():
    def __init__(self, message=""):
        self.message = message

class StreamToClient():
    def is_stream_available(self):
        return False

    def stream_to_client(self, data):
        pass

class GenericServer():
    CONFIG_OPENLOGS_ON_NEW_SERVICE = 'openlogs_on_new_service'
    CONFIG_LOG_DESTINATION = 'log_destination'
    def __init__(self, service_factory=None, stream_client=None, handle_exceptions=True):
        self.stream_client = stream_client

        if not service_factory:
            self.service_factory = ServiceFactory()
        else:
            self.service_factory = service_factory

        self.service_dict = {}
        self.URL_ARG = 'url'
        self.CONTENT_OBJECT_ARG = 'content_object'
        self.CONTENT_JSON_ARG = 'content_json'
        self.FORCE_JSON_RESPONSE = 'force_json_response'
        self.logger = server_logger
        self.streamer = None
        self.handle_exceptions = handle_exceptions
        self.stream_log_time = datetime.datetime.now()
        self.logger_process = None
        self.config_openlogs_on_new_service = False
        self.config_log_destination = None
        self.dead = False
        self.file_logs = False

    def enable_file_logs(self):
        self.file_logs = True

    def std_route(function):
        '''
        This decorator checks if the input was sent as json and if so, parses the json to the content_object param.
        If the input was json, the route transforms the response to json also.
        kwargs:
        name
        content_json
        content_object
        url

        - If CONTENT_JSON_ARG is present, sets content_object to the object parsed from CONTENT_JSON_ARG and then transforms the object returned by function to json and returns that.
            - If a parsing error occurs, the function call is bypassed and an error response is returned
        - Else If CONTENT_OBJECT_ARG is present, calls function with this object and returns whatever function returned.
        - Else CONTENT_OBJECT_ARG is set to an empty object (GenericRequest) and calls function with this object and returns whatever function returned.
        '''
        def process_std_route(self, *args, **kwargs):
            response_object = None

            if self.CONTENT_OBJECT_ARG not in kwargs:
                #If no content_object and content_json was passed, set an empty content_object
                kwargs[self.CONTENT_OBJECT_ARG] = GenericRequest()

            #if no url attr was directly passed, search for one in the content_object
            #If arg url= is not present or none and the content object has attribute "url"
            if (self.URL_ARG not in kwargs or kwargs[self.URL_ARG] is None) and hasattr(kwargs[self.CONTENT_OBJECT_ARG], self.URL_ARG):
                kwargs[self.URL_ARG] = getattr(kwargs[self.CONTENT_OBJECT_ARG], self.URL_ARG)

            if self.URL_ARG in kwargs and '_enable_log' in kwargs:
                self.logger.debug("URL: %s", kwargs[self.URL_ARG])

            response_object = function(self, **kwargs)

            if response_object is None:
                raise Exception("Server function %s did not return anything. Server with decorator std_route must return a subclass of GenericResponse." % function.__name__)

            return response_object
        return process_std_route

    def std_exception_handling(function):
        def exception_handling(self, *args, **kwargs):
            response_object = None
            try:
                response_object = function(self, *args, **kwargs)
            except Exception as e:
                response_object = self._handle_exception(e)

            return response_object
        return exception_handling

    def _handle_exception(self, e):
        logger = self.logger
        if hasattr(e, 'service') and e.service is not None:
            msg = str(e).decode('ascii', 'ignore')
            e.message = "%s: %s" % (e.service.logger_name, msg)
            logger = e.service.logger

        if isinstance(e, ServiceError):
            response_object = self._response_client_error(e, logger=logger)
        else:
            response_object = self._response_server_error(e, logger=logger)
        return response_object

    def std_json_parsing(function):
        """
        Checks if content was passed as json and if so, parse to content object.
        If json response is expected (if forced or if request was json), then
        encodes response body to json.
        """
        def json_parsing(self, *args, **kwargs):
            response = None
            if self.std_route_is_json_request(**kwargs):
                #JSON request
                try:
                    kwargs[self.CONTENT_OBJECT_ARG] = json_to_object(kwargs.pop(self.CONTENT_JSON_ARG))
                    kwargs[self.FORCE_JSON_RESPONSE] = True
                except Exception as e:
                    response = self._response_client_error(e)

            if response == None:
                #All good up to now (no error parsing json)
                response = function(self, *args, **kwargs)

            if self._should_return_json(**kwargs):
                #encode response in json
                try:
                    response.body = object_to_json(response.body)
                except Exception as e:
                    #Unable to encode in JSON, server error
                    response = self._response_server_error(e)
                    response.body = object_to_json(response.body)

            return response
        return json_parsing

    def _should_return_json(self, **kwargs):
        request_was_json = self.CONTENT_JSON_ARG in kwargs
        force_json_response = False if (self.FORCE_JSON_RESPONSE not in kwargs) else kwargs[self.FORCE_JSON_RESPONSE]
        return request_was_json or force_json_response

    def std_log_request(log_name):
        def log_request_args(function):
            def log_request(self, *args, **kwargs):

                self.logger.debug("REQUEST %s", log_name)
                kwargs['_enable_log'] = True
                return_value = function(self, *args, **kwargs)

                self.logger.debug("END OF REQUEST %s", log_name)
                return return_value

            return log_request
        return log_request_args

    def _response_client_error(self, exception, logger=None):
        if logger is None:
            logger = self.logger
        logger.warning("Client error [%s]" % str(exception).decode('ascii', 'ignore'))
        logger.debug(traceback.format_exc())
        response_object = ErrorResponse(status_code=400, message = "Client error", error=exception)
        return response_object

    def _response_server_error(self, exception, logger=None):
        if logger is None:
            logger = self.logger
        logger.error("Server error [%s]" % str(exception).decode('ascii', 'ignore'))
        logger.error(traceback.format_exc())
        response_object = ErrorResponse(status_code=500, message = "Server error", error=exception)
        return response_object

    def std_route_is_json_request(self, **kwargs):
        return self.CONTENT_JSON_ARG in kwargs

    def service_url_exists(function):
        def check_service_url_exists(self, *args, **kwargs):
            if self.URL_ARG not in kwargs:
                resp = ErrorResponse(status_code=400, error=ServiceError("No url specified."))
            elif not self.does_service_exists(kwargs[self.URL_ARG]):
                resp = ErrorResponse(status_code=404, error=ServiceError("No Service at url %s." % kwargs[self.URL_ARG]))
            #elif self.service_dict[self.URL_ARG] is None:
            #    resp = ErrorResponse(status_code=400, error=ServiceError("Service reserved only. Use create_service before trying to use the service."))
            else:
                resp = function(self, *args, **kwargs)
            return resp
        return check_service_url_exists

    @std_log_request("CONFIG")
    @std_json_parsing
    @std_exception_handling
    @std_route
    def server_config(self, url="", content_object=None, **kwargs):
        if hasattr(content_object, GenericServer.CONFIG_OPENLOGS_ON_NEW_SERVICE):
            value = getattr(content_object, GenericServer.CONFIG_OPENLOGS_ON_NEW_SERVICE)
            self.logger.info("openlogs on new service set to %s", str(value))
            self.config_openlogs_on_new_service = value

        if hasattr(content_object, GenericServer.CONFIG_LOG_DESTINATION):
            value = getattr(content_object, GenericServer.CONFIG_LOG_DESTINATION)
            self.logger.info("Log destination set to %s", str(value))
            self.config_log_destination = value

        return GenericResponse(message="Configuration done.")

    @std_log_request("NEW SERVICE")
    @std_json_parsing
    @std_exception_handling
    @std_route
    def new_service(self, url="", content_object=None, **kwargs):
        config = content_object
        resp = GenericResponse()
        resp.body = None

        file_log = self._try_extract_param(config, "file_log", default=True)
        overwrite = self._try_extract_param(config, "overwrite", default=True)
        reservation = self._try_extract_param(config, "reservation", default=False)

        if reservation:
            self.logger.debug("Reservation only, no configuration will be executed")

        existant_and_overwrite = overwrite and url in self.service_dict
        inexistant = url not in self.service_dict

        configure = not reservation
        service = None
        if existant_and_overwrite and self.service_dict[url].configured:
            self.service_dict[url].base_service_shutdown()
            service = self.log_service_factory_new_service(url, config, file_log=self.file_logs)
            resp.status_code = 201
            resp.body = GenericResponseBody(message="Service created, previous service at url was overwritten.")
        elif inexistant:
            service = self.log_service_factory_new_service(url, config, file_log=self.file_logs)
            if self.config_openlogs_on_new_service:
                #Re opens the logs with the added service log
                self.openlogs()
            resp.status_code = 201
            resp.body = GenericResponseBody(message="Service created.")
        else:
            resp.status_code = 200
            resp.body = GenericResponseBody(message="Service already exists.")
            service = self.service_dict[url]

        if configure and not service.configured:
            service.base_service_config(config)
            resp.body.message = resp.body.message + " Service configured."

        #No errors up to now, ready to be added to service dict
        self.service_dict[url] = service
        self.logger.debug("SERVICE ADDED TO SERVER")

        return resp

    def _try_extract_param(self, content, param_name, default=None):
        value = default
        try:
            value = getattr(content, param_name)
            self.logger.info("Param %s specified: %s" % (param_name, str(file_log)))
        except Exception as e:
            pass
        return value

    def log_service_factory_new_service(self, *args, **kwargs):
        try:
            service = self.service_factory.new_service(*args, **kwargs)
            return service
        except:
            self.logger.warning("SERVICE CREATION ABORTED")
            raise

    @std_log_request("SERVICE")
    @std_json_parsing
    @std_exception_handling
    @std_route
    @service_url_exists
    def service(self,url="", content_object=None,*args,  **kwargs):
        '''
        Services the specified url with the specified content_object.
        '''
        return self.internal_service(url, content_object, *args, **kwargs)

    def internal_service(self, url="", content_object=None,*args,  **kwargs):
        resp = GenericResponse()
        resp.body = self.service_dict[url].base_service_handle(content_object)

        return resp

    @std_json_parsing
    @std_exception_handling
    @std_route
    @service_url_exists
    def stream_route(self, url="", content_object=None,*args,  **kwargs):
        resp = GenericResponse()
        resp.body = self.service_dict[url].base_stream_poll(content_object)
        return resp

    def get_all_services(self):
        for url, service in self.service_dict.items():
            desc = "(" + service.service_uuid() + ")" + str(service)
            yield url, desc

    @std_log_request("GET SERVICE")
    @std_json_parsing
    @std_exception_handling
    @std_route
    @service_url_exists
    def get_service(self, url="", content_object=None):
        resp = GenericResponse()
        resp.body = self.service_dict[url].base_get_service(content_object)
        return resp

    @std_json_parsing
    @std_exception_handling
    @std_route
    def shutdown(self, url="", content_object=None, **kwargs):
        """
        :param content_object.move_logs: Absolute path of move destination directory
        """

        self.logger.info("SHUTDOWN")
        self.kill_logger()

        for url, service in self.service_dict.iteritems():
            if service is not None:
                service.base_service_shutdown()

        dst = self.config_log_destination
        if hasattr(content_object, "move_logs"):
            dst = content_object.move_logs

        if dst is not None:
            self.logger.info("Moving server logs to %s", dst)
            self.move_logs(dst)

        self.dead = True
        return GenericResponse(message="Bye :(")

    def kill_logger(self):
        if self.logger_process is not None:
            self.logger_process.kill()
            self.logger_process.wait()

    @std_log_request("OPEN LOGS")
    @std_json_parsing
    @std_exception_handling
    @std_route
    def launch_tail_log(self, url="", content_object=None, **kwargs):
        self.openlogs()
        return GenericResponse(message="Tails logging program launched.")

    def openlogs(self):
        self.kill_logger()

        path = os.path.dirname(os.path.realpath(__file__))
        path = os.path.join(path, 'instances', std_server_name(__builtin__.SERVER_NAME, __builtin__.SERVER_PORT))
        self.logger_process = multipletail.start_tail_logs_program(path)

    def move_logs(self, dst):
        path = __builtin__.SERVER_FILES_PATH
        import shutil
        from nute import utils
        if os.path.exists(dst):
            utils.merge_dir(dst, path)
            shutil.rmtree(dst)
            shutil.copytree(path, dst)
        else:
            shutil.copytree(path, dst)
        logging.shutdown()
        shutil.rmtree(path)

    @std_log_request("SHELL")
    @std_json_parsing
    @std_exception_handling
    @std_route
    @service_url_exists
    def interactive_shell(self, url="", content_object=None, **kwargs):
        """
        Uses the msg attribute of the content_object to call the interactive_function of the service at url.
        :param content_object.msg: shell input, to be processed by the service interactive_function
        """
        resp = GenericResponse()
        resp.body = self.service_dict[url].base_shell(content_object.msg)
        return resp

    def does_service_exists(self, url):
        return url in self.service_dict
