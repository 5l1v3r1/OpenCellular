
import requests
import logging
import os
import __builtin__

from opentest.server.jsonutils import *
from opentest.server import serverconst

import threading
import time
import datetime


class ServiceError(Exception):
    def __init__(self, message="", service=None):
        Exception.__init__(self, message)
        self.service = service

class ServiceRequest():
    pass

class Service(object):
    """
    Base class of all Services. ServiceFactory uses the declared subclasses of this class to search for UUIDs.
    The UUID of the service should be declared as a global variable in caps before the declaration of the class:
    SOME_SERVICE_UUID = "my_service"
    class SomeService(Service):
        def __init__(self, url, **kwargs):
            Service.__init__(self, url, **kwargs)
            ...

        ...

        @staticmethod
        def service_uuid():
            return SOME_SERVICE_UUID

    """
    def __init__(self, url, create_file_log=False, **kwargs):
        """
        The constructor of sub classes must only take one argument, the url of the http route.
        The url of the service is different from its UUID; the same server may have multiple copies of the same service at different urls.
        """
        self.url = url
        self.stream_log_time = datetime.datetime.now()
        self.logger_name = type(self).__name__ + '@' + self.url
        self.logger = logging.getLogger(serverconst.SERVICE_NAME + '.' +self.logger_name)
        self.file_handler = None
        self.configured = False
        if create_file_log:
            self._setup_file_log()
        self.logger.debug("\n\n")
        self.log_entry_message = ''
        self.logger.info("SERVICE INITIALIZED")

    def _setup_file_log(self):
        SERVER_LOGS_PATH = __builtin__.SERVER_FILES_PATH
        path = os.path.dirname(os.path.realpath(__file__))
        path = os.path.join(SERVER_LOGS_PATH, serverconst.SERVICE_LOGS)
        if not os.path.isdir(path):
            os.mkdir(path)

        self.file_handler = logging.FileHandler(os.path.join(path, self.logger_name + '.log'))
        self.file_handler.setLevel(logging.DEBUG)

        formatter = logging.Formatter('%(asctime)s:%(levelname)-8s %(message)s')
        self.file_handler.setFormatter(formatter)

        #Remove all handlers
        self.logger.handlers = []

        self.logger.addHandler(self.file_handler)
        self.logger.setLevel(logging.DEBUG)

    def extract_param(self, content_object, param_name, default=None, default_none_allowed=False):

        value = None
        found = False
        try:
            value = getattr(content_object, param_name)
            found = True
        except:
            pass

        if found:
            pass
        elif not found and (default is not None or default_none_allowed):
            value = default
        else:
            message = 'Unable to find required parameter ' + param_name
            self.service_error(message)

        return value

    def log_entry(name):
        def _log_entry_fn(function):
            def _log_entry(self, *args, **kwargs):
                #self.logger.debug("%s" % name)
                begin_time = time.time()
                return_value = function(self, *args, **kwargs)
                took = time.time()-begin_time
                self.logger.info("%s - %s (%s s)" % (name, self.log_entry_message, str(round(took, 2))))
                self.log_entry_message = ''
                return return_value
            return _log_entry
        return _log_entry_fn

    def is_configured(function):
        def _is_configured(self, *args, **kwargs):
            if self.configured:
                return function(self, *args, **kwargs)
            else:
                self.service_error("Service must be configured before usage (create_service)")
        return _is_configured

    def service_error(self, message):
        raise ServiceError(message, service=self)

    def quick_log(self, message):
        if self.log_entry_message != '':
            self.log_entry_message = '%s - %s' % (self.log_entry_message, message)
        else:
            self.log_entry_message = message

    @log_entry('SERVICE CONFIGURATION')
    def base_service_config(self, config):
        '''
        Basic defined config attributes:
        loglevel=[DEBUG, INFO, WARNING, ERROR, CRITICAL]

        '''
        '''Extract Logging level'''
        loglevel = self.extract_param(config, 'loglevel', default='DEBUG')

        numeric_level = getattr(logging, loglevel.upper(), None)
        if not isinstance(numeric_level, int):
            self.logger.warning("Logging level received invalid")
            numeric_level = logging.INFO

        self.logger.setLevel(numeric_level)
        if self.file_handler is not None:
            self.file_handler.setLevel(numeric_level)
        self.quick_log("LOG =" + str(logging.getLevelName(numeric_level)))

        '''Actual service config implementation'''
        self._standard_function_error_handling(self.service_config, config)
        self.configured = True

    def _standard_function_error_handling(self, function, *args, **kwargs):
        try:
            return function(*args, **kwargs)
        except Exception as e:
            self.logger.debug("Unexpected error occured while handling request")
            e.service = self
            raise

    def service_config(self, config):
        """
        MUST BE IMPLEMENTED
        Called on creation of the service. Config is created from the json content of the request.
        Although Service and ServiceFactory do not require a defining object, one should be given if one wishes to programatically call the HTTP server.
        class MyConfig():
            def __init__(self):
                self.some_param1
                self.some_param2
                ...

        The passed object WILL NOT BE of type MyConfig if decoded from json. However, it will contain some_param1 and some_param2 if the json is encoded and decoded using jsonutils' (object_to_json() and json_to_object())
        """
        raise NotImplementedError

    @log_entry('SERVICE HANDLING')
    @is_configured
    def base_service_handle(self, request):
        '''
        Basic defined service attributes:

        '''
        resp = None
        resp = self._standard_function_error_handling(self.service_handle, request)
        return resp

    def service_handle(self, request):
        """
        MUST BE IMPLEMENTED
        Just like the config, request is created from the content of a request. A class containing the attributes should be made available, but the passed object will not be of this type.
        Returns the response. May be a generator function to return multiple responses.
        """
        raise NotImplementedError


    @log_entry('SERVICE GET')
    def base_get_service(self, request):
        try:
            self.get_service(request)
        except NotImplementedError:
            self.logger.info("Using default implementation")
        return self.logger_name

    def get_service(self, request):
        raise NotImplementedError

    @is_configured
    def base_stream_poll(self, request):
        '''No STREAMING log
        current_time = datetime.datetime.now()
        if current_time - self.stream_log_time > datetime.timedelta(seconds=1.0):
            self.logger.info("STREAMING")
            self.stream_log_time = current_time
        '''
        return self.stream_poll(request)

    def stream_poll(self, request):
        pass

    def service_url(self):
        return self.url

    def base_service_shutdown(self):
        try:
            self.service_shutdown()
            self.logger.info("SERVICE SHUTDOWN COMPLETE")
        except Exception as e:
            self.logger.error("%s: %s" % (type(e).__name__, str(e)))

    def service_shutdown(self):
        """
        Can be overriden to implement closing behaviors
        """

    @log_entry('SHELL')
    def base_shell(self, msg):
        return self.interactive_function(msg)

    def interactive_function(self, msg):
        """
        Can be overriden to implement server side command line interaction
        This should call a standard service route with appropriate arguments
        :param msg: The message entered by the user at the command line
        """

    @staticmethod
    def service_uuid():
        """
        DEPRECATED
        UUID is now the name of the class, E.g. COMService
        """
        return ""

class StreamToLogger(threading.Thread):
    """
    Fake file-like stream object that redirects writes to a logger instance.
    """
    def __init__(self, logger, log_level=logging.INFO):
        self.logger = logger
        self.log_level = log_level
        self.linebuf = ''

    def write(self, buf):
        for line in buf.rstrip().splitlines():
            self.logger.log(self.log_level, line.rstrip())

from nute import utils
class ServiceFactory(object):
    """
        Creates services based on class reflection and classes UUID.
        The point of the factory is to be able to create the appropriate Service based on a string uuid using the new_service method
    """
    def __init__(self, additionnal_import_paths=[], import_factory_folder=True, ignore_import_errors=True):
        self.logger = logging.getLogger(serverconst.SERVICE_NAME + '.ServiceFactory')
        self.class_finder = utils.ClassFinder(logger=self.logger, ignore_import_errors=ignore_import_errors)

        if import_factory_folder:
            file_dir = os.path.dirname(os.path.realpath(__file__))
            self.class_finder.import_path(file_dir, ignore_files= ['base', '__init__'])

        for path in additionnal_import_paths:
            self.class_finder.import_path(path)

    def new_service_class(self, claz, url, file_log=False):
        serv = claz(url, create_file_log= file_log)
        return serv

    def new_service(self, url, config_object, uuid=None, file_log=False):
        """
        Creates a service sub class

        :param uuid: The unique identifier of a sub class of Service. Compared with the class' service_uuid() static method
        :param url: The url at which the service should be launched (the factory only initializes the service's url attribute)
        :param config_object: The object which is passed to the service_config method. if uuid param is None, an attribute uuid will be searched in this object
        """
        if uuid is None:
            if hasattr(config_object, 'uuid'):
                uuid = config_object.uuid
            else:
                raise ServiceError("New service requires valid member uuid")

        self.logger.debug("Building service with UUID %s", str(uuid))

        return self._create_class_from_uuid(Service, uuid, url=url, create_file_log=file_log)

    def _create_class_from_uuid(self, root_cls, uuid, accept_root=False, *args, **kwargs):
        if not uuid:
            raise ServiceError("UUID is empty")
        ## Following block is to support full describing paths
        uuid_prefix, uuid = self._try_class_finder_import_full_describing_path(uuid)

        claz = self.class_finder.find_first_subclass_with_name(root_cls, uuid)
        names = [n.__name__ for n in self.class_finder.yield_subclasses(root_cls)]
        if claz is not None:
            return claz(*args, **kwargs)

        #If we get here, we did not find it.
        import difflib
        matches = difflib.get_close_matches(uuid, names)
        uuid = uuid_prefix + '.' + uuid
        additionnal_message = ''
        if self.class_finder.import_errors:
            additionnal_message = 'Note that some modules raised ImportErrors:'
            for error in self.class_finder.import_errors:
                additionnal_message = additionnal_message + '\n' + error

        if len(matches) > 0:
            raise ServiceError("%s does not exists. Did you mean %s ? %s" % (uuid, matches[0], additionnal_message))
        else:
            raise ServiceError("%s does not exists. No close match. %s" % (uuid, additionnal_message))

    def _try_class_finder_import_full_describing_path(self, uuid):
        uuid_as_module = uuid.split('.')
        uuid_prefix = ""
        if len(uuid_as_module) > 1:
            ## E.g. tools.folder.script.SomeClass
            # -> module = tools.folder.script
            # -> uuid = SomeClass
            uuid_prefix = '.'.join(uuid_as_module[:-1])
            previous_ignore = self.class_finder.ignore_import_errors
            self.class_finder.ignore_import_errors = False #Activate import errors, since the user explicitely wants to import this file
            try:
                self.class_finder.import_module(uuid_prefix)
            except ImportError as e:
                raise ImportError("%s in module path [%s]" % (e.message, uuid_prefix))
            self.class_finder.ignore_import_errors = previous_ignore #Restore old import error settings
            uuid = uuid_as_module[-1]
        return uuid_prefix, uuid

    def new_service_client(self, class_name, url, port, ip='127.0.0.1'):
        return self._create_class_from_uuid(ServiceClient, class_name, url=url, ip=ip, port=port, accept_root=True)

class RemoteServerError(Exception):
    def __init__(self, client, response_body, status_code):
        self.status_code = status_code
        self.call_type = client._current_call
        self.remote_url = client.interface.url
        self.remote_format_exc = response_body.format_exc
        self.remote_exc_message = response_body.exception_message
        self.remote_exc_type = response_body.exception_type
        Exception.__init__(self, "[%d] %s call @%s: %s: %s" % (status_code, self.call_type, self.remote_url, self.remote_exc_type, self.remote_exc_message))


class ServiceClient(object):
    def __init__(self, *args, **kwargs):
        '''
        Initializes the ServiceClient base class
        By default, the service interface is the REST interface which uses http requests.
        It requires kwargs 'url' and 'port'
        A non-default interface may be passed as kwarg 'interface'
        '''
        if 'interface' in kwargs:
            self.interface = kwargs['interface']
        else:
            self.interface = RESTServiceClientInterface()

        if 'logger' in kwargs:
            self.set_logger(kwargs['logger'])
        else:
            self.set_logger(logging.getLogger())

        self.interface.interface_init(*args, **kwargs)
        self.interface.on_message = self.on_stream_message
        self._context_flag = False
        self._call_allowed = True
        self._current_call = None

    def set_logger(self, logger):
        logger_name = self.__class__.__name__
        self.logger = logger.getChild(logger_name)

    def begin_call_blocking(self, exception=None):
        if exception is not None:
            self._call_blocked_exception = exception
        else:
            self._call_blocked_exception = ServiceError("Requests blocked in ServiceClient (begin_call_blocking)")

        self._call_allowed = False
        self.end_poll_early()

    def end_call_blocking(self):
        self._call_allowed = True

    def __enter__(self):
        self._context_flag = True
        return self

    def __exit__(self, type, value, traceback):
        self._context_flag = False
        self.interface.stream_close()

    def if_call_allowed(function):
        def _if_call_allowed(self, *args, **kwargs):
            if self._call_allowed:
                return function(self, *args, **kwargs)
            else:
                raise self._call_blocked_exception
        return _if_call_allowed


    def new_service(self, **kwargs):
        self._current_call = "NEW SERVICE"
        return self.std_service(self.base_new_service_request, **kwargs)

    def service(self, **kwargs):
        self._current_call = "SERVICE"
        return self.std_service(self.base_service_request, **kwargs)

    def get_service(self, **kwargs):
        self._current_call = "GET SERVICE"
        return self.std_service(self.base_get_service_request, **kwargs)

    def shell(self, msg):
        self._current_call = "SHELL"
        return self.std_service(self.base_shell, msg=msg)

    def std_service(self, fn, **kwargs):
        req = self._kwargs_to_content_object(**kwargs)
        status_code, resp = fn(req)

        #Raise exception if resp contains the standard exception_message attribute
        if hasattr(resp, "message"):
            pass
            #self.logger.info(resp.message)
        if hasattr(resp, "warning"):
            self.logger.warning(resp.warning)
        if hasattr(resp, "exception_message"):
            raise RemoteServerError(self, resp, status_code)

        return status_code, resp

    def _kwargs_to_content_object(self, **kwargs):
        req = ServiceRequest()
        for key, value in kwargs.items():
            setattr(req, key, value)
        return req

    def on_stream_content(self, content):
        pass


    def on_stream_message(self, message):
        content_string = str(message)
        content = None
        try:
            content = json_to_object(content_string)
        except Exception as e:
            #Probably a SENT message
            pass
        if content is not None:
            self.on_stream_content(content)


    def poll(self, callback_fn, interval, timeout,  **kwargs):
        """
        Returns a StreamHandle:
        def is_done(self):
            returns if the stream is closed

        def wait_timeout(self, timeout):
            wait at most timeout if the stream closes, returns is_done
        """
        handle = self.poll_async(callback_fn, interval, **kwargs)
        handle.wait_timeout(timeout=timeout)
        self.interface.stream_close()

    @if_call_allowed
    def poll_async(self, callback_fn, interval, **kwargs):
        assert self._context_flag, "Poll must be used within a context manager (with ... block)."
        req = self._kwargs_to_content_object(**kwargs)
        self.on_stream_content = callback_fn
        handle = self.interface.stream(req, interval=interval)
        return handle

    def end_poll_early(self):
        self.interface.stream_close()

    @if_call_allowed
    def base_new_service_request(self, content):
        return self.interface.new_service(content)

    @if_call_allowed
    def base_service_request(self, content):
        return self.interface.service(content)

    @if_call_allowed
    def base_get_service_request(self, content):
        return self.interface.get_service(content)

    @if_call_allowed
    def base_shell(self, content):
        return self.interface.shell(content)

class ServiceClientInterface(object):

    def interface_init(self, *args, **kwargs):
        pass

    def on_message(self, content):
        pass

    def new_service(self, content):
        '''
        Returns two values : status_code, content
        '''
        raise NotImplementedError

    def service(self, content):
        '''
        Returns two values : status_code, content
        '''
        raise NotImplementedError

    def get_service(self):
        '''
        Returns two values : status_code, content
        '''
        raise NotImplementedError

    def stream(self, content, interval=1):
        '''
        Returns two values : status_code, content
        '''
        raise NotImplementedError

    def stream_close(self):
        pass

    def shell(self, msg):
        '''
        Returns two values : status_code, content
        '''
        raise NotImplementedError

class RESTServiceClientInterface(ServiceClientInterface):
    '''
    Standard client interface, uses post, put and get http methods to a remote server.
    '''

    def interface_init(self, *args, **kwargs):
        self.url = kwargs['url']
        self.port = kwargs['port']
        if 'ip' in kwargs:
            self.ip = kwargs['ip']
        else:
            self.ip = '127.0.0.1'
        base_url = self.ip + ":" + str(self.port) + "/service"
        if self.url is not None and self.url is not "":
            base_url = base_url + "/" + self.url
        self.http_url = "http://" + base_url
        self.ws_url = "ws://" + base_url
        self.stream_thread = None
        self.log_time = datetime.datetime.now()

    def handle_connection_errors(function):
        def connection_errors_handling(*args, **kwargs):
            return function(*args, **kwargs)
        return connection_errors_handling

    @handle_connection_errors
    def new_service(self, content):
        return self._standard_request(requests.post, content)

    @handle_connection_errors
    def service(self, content):
        return self._standard_request(requests.put, content)

    @handle_connection_errors
    def get_service(self):
        resp = requests.get(self.http_url)
        return resp.status_code, json_to_object(resp.text)

    @handle_connection_errors
    def stream(self, content, interval=1):
        self.stream_thread = PollingClientStreamThread(self.on_message, self.http_url, object_to_json(content), interval=interval)
        handle = StreamHandle(self.stream_thread)
        self.stream_thread.start()
        return handle

    def stream_close(self):
        if self.stream_thread is not None:
            self.stream_thread.kill_thread()
            self.stream_thread = None

    @handle_connection_errors
    def shell(self, content):
        return self._standard_request(requests.put, content, params={'shell': True})

    def _standard_request(self, fn, content, **kwargs):
        resp = fn(self.http_url, object_to_json(content), **kwargs)
        return resp.status_code, json_to_object(resp.text)

class StreamHandle(object):
    def __init__(self, stream_thread):
        self.thread = stream_thread

    def is_done(self):
        return self.thread is None or not self.thread.isAlive()

    def wait_timeout(self, timeout):
        while timeout > 0 and not self.is_done():
            time.sleep(0.05)
            timeout = timeout - 0.05
        return self.is_done()


class PollingClientStreamThread(threading.Thread):
    def __init__(self, on_message_fn, url, content, interval=0.5):
        threading.Thread.__init__(self)
        self.url = url
        self.content = content
        self.on_message = on_message_fn
        self.setDaemon(True)
        self.run_flag = True
        self.interval = interval

    def run(self):
        while self.run_flag:
            resp = requests.put(self.url, self.content, params={'stream': True})
            self.on_message(resp.text)
            time.sleep(self.interval)

    def kill_thread(self):
        if self.run_flag:
            self.run_flag = False

class DirectServiceClientInterface(ServiceClientInterface):
    '''
    Local Server object client interface. uses an existing GenericServer instance and makes direct python calls to its handling functions.
    Transforms in JSON
    Useful for client tests
    '''

    def interface_init(self, *args, **kwargs):
        self.url = kwargs['url']
        self.server = kwargs['server']
        self.server.stream_client = self

    def is_stream_available(self):
        return True

    def stream_to_client(self, content):
        self.on_message(object_to_json(content))

    def new_service(self, content):
        resp = self.server.new_service(url=self.url, content_json=object_to_json(content))
        return resp.status_code, json_to_object(resp.body)

    def service(self, content):
        resp = self.server.service(url=self.url, content_json=object_to_json(content))
        return resp.status_code, json_to_object(resp.body)

    def get_service(self):
        resp = self.server.get_service(url=self.url, content_json=None)
        return resp.status_code, json_to_object(resp.body)

    def stream(self, content, interval=1, timeout=1):
        #TODO directinterface interval and timeout not implemented
        while timeout > 0:
            resp = self.server.stream_route(url=self.url, content_json=object_to_json(content))
            self.on_message(json_to_object(resp.body))
            time.sleep(interval)
            timeout = timeout - interval


    def stream_close(self):
        pass
