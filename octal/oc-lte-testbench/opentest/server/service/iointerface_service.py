from base import *
from support.iointerface import IOInterfaceDaemon, COMInterface, SSHInterface
import threading

import StringIO

IO_INTERFACE_SERVICE_UUID = "iointerface"

class IOInterfaceServiceConfig():
    def __init__(self):
        self.interface_name = ""

class IOInterfaceServiceRequest():
    '''
    :param message: (optional) write message to io interface. If empty, nothing is written.
    :param readlines: (optional) read this number of lines from the interface and return them.
    '''
    def __init__(self):
        self.message = ""
        self.keeplines = -1
        self.readlines = 0

class IOInterfaceServiceResponse():
    '''
    :param written: What was written to the io interface during the request
    :param read: What was read from the io interface during the request (because of readlines > 0)
    '''
    def __init__(self):
        self.written = ""
        self.read = ""

class IOInterfaceError(ServiceError):
    pass

class IOInterfaceService(Service):
    def __init__(self, url, **kwargs):
        Service.__init__(self, url, **kwargs)
        self.daemon = IOInterfaceDaemon()
        self.interface = None
        self.write_event = threading.Event()


    def write_callback_impl(self, written):
        self.logger.info(">%s", repr(written))
        self.write_event.set()

    def read_callback_impl(self, read):
        self.logger.debug(read.strip())

    def service_config(self, config):
        try:
            self.logger.debug("Configuring interface")
            self.interface = self.configure_interface(config)

            if self.interface is not None:
                self.logger.debug("Starting daemon threads")
                self.daemon.start(self.interface)
                self.daemon.writer_thread.write_callback = self.write_callback_impl
                self.daemon.reader_thread.read_callback = self.read_callback_impl
            else:
                raise IOInterfaceError("Interface returned is none")
        except Exception as e:
            raise
        self.quick_log('SUCCESS')

    def configure_interface(self, config):
        #To be overidden by children
        return None

    def teardown_interface(self):
        pass

    def if_interface_exists(function):
        def check_interface_exists(*args, **kwargs):
            _self = args[0]
            if _self.interface is not None:
                return function(*args, **kwargs)
            else:
                _self.logger.warning("Interface not initialized")
                raise Exception("Interface not initialized. Check child implementation.")

        return check_interface_exists

    @if_interface_exists
    def service_handle(self, request):
        response = IOInterfaceServiceResponse()
        message = self.extract_param(request, 'message', default="")
        keeplines = self.extract_param(request, 'keeplines', default=-1)

        if keeplines >= 0:
            current_lines = self.daemon.get_approx_read_data_available()
            self.quick_log("KEEP %d/%d lines" %  (keeplines, current_lines))
            while current_lines > keeplines:
                self.daemon.read_async()
                current_lines = current_lines - 1

        if message != "" and message != None:
            self.write_event.clear()
            self.daemon.write_async(message)
            self.write_event.wait(timeout=0.5)
            response.written = message

        readlines = self.extract_param(request, 'readlines', default=0)
        timeout = self.extract_param(request, 'timeout', default=0.5)
        if readlines > 0:
            self.quick_log("%d lines requested, timeout is %.1f seconds" % (readlines, timeout))

        while readlines > 0:
            line = self.daemon.read_async(timeout=timeout)
            response.read = response.read + line
            readlines = readlines - 1

        return response

    @if_interface_exists
    def stream_poll(self, request):
        response = IOInterfaceServiceResponse()
        resp_interresting = False
        if request is not None:
            write_resp = self.service_handle(request)
            response.written = write_resp.written
            if response.written != "" or response.read != "":
                resp_interresting = True

        lines_to_read = self.daemon.get_approx_read_data_available()
        #print(lines_to_read)
        while lines_to_read > 0:
            response.read = response.read + self.daemon.read_async()
            resp_interresting = True
            lines_to_read = lines_to_read - 1

        if resp_interresting:
            return response
        else:
            return None

    def service_shutdown(self):
        self.daemon.kill()

    def interactive_function(self, msg):
        """
        Can be overriden to implement server side command line interaction
        This should call a standard service route with appropriate arguments
        :param msg: The message entered by the user at the command line
        """
        req = IOInterfaceServiceRequest()
        req.message = msg
        return self.service_handle(req)

    @staticmethod
    def service_uuid():
        return IO_INTERFACE_SERVICE_UUID

class IOInterfaceServiceClient(ServiceClient):

    def __init__(self, *args, **kwargs):
        ServiceClient.__init__(self, *args, **kwargs)

COM_SERVICE_UUID = "cominterface"

class COMService(IOInterfaceService):

    def configure_interface(self, config):
        return COMInterface(config.port, config.baudrate)

    @staticmethod
    def service_uuid():
        return COM_SERVICE_UUID

class COMException(Exception):
    pass

class COMServiceClient(ServiceClient):

    def create_service(self, com, baudrate=115200):
        status, resp = self.new_service(uuid=COMService.__name__, port=com, baudrate=baudrate)
        assert status < 400

    def com_target(self, msg, target, timeoutlimit, keeplines=0, poll_rate=0.05):
        contentstring = StringIO.StringIO()
        targets = self._parse_target(target)
        def callback(content):
            contentstring.write(content.read)
            for targetstr in targets:
                if targetstr in content.read:
                    self.end_poll_early()
        with self as client:
            client.service(message=msg, keeplines=keeplines)
            client.poll(callback, poll_rate, timeoutlimit)
        contentlog = contentstring.getvalue()
        contentstring.close()
        return contentlog

    def is_target_in_response(self, target, response):
        targets = self._parse_target(target)
        for targetstr in targets:
            if targetstr in response:
                return True
        else:
            return False

    def _parse_target(self, targetstr):
        TEMP_ESCAPE_OR_STRING = r"\orescape"

        if targetstr is None:
            or_target_strings = []
        else:
            targetstr = targetstr.replace('\|', TEMP_ESCAPE_OR_STRING)
            or_target_strings = targetstr.split('|')

        for i in range(0, len(or_target_strings)):
            or_target_strings[i] = or_target_strings[i].replace(TEMP_ESCAPE_OR_STRING, '|')

        return or_target_strings

    def com_read(self, timeoutlimit):
        contentread = StringIO.StringIO()
        def callbackR(content):
            contentread.write(content.read)
        self.poll(callbackR, 0.05, timeoutlimit)
        contentr = contentread.getvalue()
        contentread.close()
        return contentr

    def com_send(self, msg):
        self.service(message=msg)

    def _get_second_to_last_line(self, string):
        lines = string.split('\n')
        cleanstr = ""
        if len(lines) >= 2:
            cleanstr = lines[-2]
            cleanstr = cleanstr.strip()
        return cleanstr
