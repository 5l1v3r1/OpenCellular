from base import *
import os
import visa
from nute import utils
import time

class VISAServiceConfig():
    def __init__(self):
        self.instrument = ""

class VISAServiceRequest():
    def __init__(self):
        self.command = ""
        self.doread = False

class VISAServiceResponse():
    def __init__(self):
        self.output = ""

VISA_SERVICE_UUID = "visa"

def _keysight_exg_get_file_header(fil):
    pass
    #http://literature.cdn.keysight.com/litweb/pdf/N5180-90056.pdf
    #for header format see link p163

    statinfo = os.stat(fil)

    content_length = statinfo.st_size

    number_of_bytes_string = str(content_length)
    number_of_digits = str(len(number_of_bytes_string))
    header = '#' + number_of_digits + number_of_bytes_string
    return header

def bytes_from_file(filename, chunksize=8192):
    with open(filename, "rb") as f:
        while True:
            chunk = f.read(chunksize)
            if chunk:
                for b in chunk:
                    yield b
            else:
                break


class VISAService(Service):
    def __init__(self, url, **kwargs):
        Service.__init__(self, url, **kwargs)
        self.instr_name = ""
        self.instr = None

    def service_config(self, config):
        self.instr_name = self.extract_param(config, "instrument")
        self.logger.info("All parameters present")
        self.connect()

    def connect(self):
        self.logger.info("Connecting to instrument [%s]", self.instr_name)
        try:
            resource_manager = visa.ResourceManager()
        except OSError:
            self.logger.error("Please install NI-VISA driver on this computer in order to use the VISA Service.")
            return
        self.instr = resource_manager.open_resource(self.instr_name)
        self.instr.timeout = 50000

    def visa_client_connected(function):
        def check_connected(*args, **kwargs):
            _self = args[0]
            if _self.instr is None:
                _self.logger.info("Connection is no longer alive")
                _self.connect()
            return function(*args, **kwargs)

        return check_connected

    @visa_client_connected
    def service_handle(self, request):
        multiple_commands = self.extract_param(request, "multiple_commands", default=[])
        command = self.extract_param(request, "command", default="")
        file_name = self.extract_param(request, "binary_file_name", default="")
        doread = self.extract_param(request, "doread", default=False)
        unstack_errors = self.extract_param(request, "unstack_errors", default=False)
        timeout = self.extract_param(request, "timeout", default=5.0)

        self.logger.debug("Timeout is %s seconds" % timeout)
        timeout = timeout*1000#to ms
        self.instr.timeout = timeout
        output = ""
        if file_name != "" and command != "":
            #Command + binary file
            binary = bytes_from_file(file_name)
            self.logger.info("Sending binary file: %s<%s>" % (command, file_name))
            self.instr.write_binary_values(command, list(binary), datatype='c')
        elif command != "":
            #Command only
            multiple_commands = [command] + multiple_commands

        output = self._try_command_x_times(self._send_commands, 3, multiple_commands, doread)

        if unstack_errors:
            self.logger.info("Unstacking all errors from instrument")
            output = output +'\n' + self._format_get_errors_read()

        resp = VISAServiceResponse()
        resp.output = output
        return resp

    def _send_commands(self, multiple_commands, doread):
        output = ''
        for cmd in multiple_commands:
            self.logger.info("Sending command: %s", cmd)
            self._try_command_x_times(self.instr.write, 3, cmd)

        try:
            if doread:
                output = self.instr.read()
                self.logger.info("Read: %s", output.strip())
            else:
                #If not expected to read, block until all operations are completed
                self.logger.debug("Waiting for operations to finish...")
                output = self.instr.query("*OPC?")
        except Exception as e:
            self.logger.info(e)
            self.logger.warning("Intrument read failed")
            self.logger.debug("Unstacking all errors from instrument")
            raise ServiceError(self._format_get_errors_read())

        return output

    def _try_command_x_times(self, fn, tries, *args, **kwargs):
        while True:
            try:
                return fn(*args, **kwargs)
            except Exception as e:
                tries = tries - 1
                if tries <= 0:
                    raise
                self.logger.warning('%s: Retrying' % str(e))

    def _format_get_errors_read(self):
        errors = self._get_errors()
        if len(errors) <= 0:
            string = "No errors but read failed: was there something to be read?"
        else:
            string = "ERRORS"
            for error in errors:
                string = string + ":" + error

        return string

    def _get_errors(self):
        ERROR_QUERY = "SYST:ERR?"
        errors = []
        error_string = self.instr.query(ERROR_QUERY)
        self.logger.debug("%s", error_string.strip())
        code, msg = error_string.split(',')
        code = code.strip()
        msg = msg.strip()
        if code != "+0":
            errors = errors + [msg]
            errors = errors + self._get_errors()

        return errors

    def stream_poll(self, request):
        raise NotImplementedError

    def service_shutdown(self):
        self.try_close()

    def try_close(self):
        if self.instr is not None:
            self.instr.close()
            self.instr = None

    @staticmethod
    def service_uuid():
        return VISA_SERVICE_UUID

class VISAServiceClient(ServiceClient):

    def __init__(self, *args, **kwargs):
        ServiceClient.__init__(self, *args, **kwargs)
        self.command_queue = []

    def create_service(self, instrument_name, **kwargs):
        status, resp = self.new_service(uuid=VISAService.__name__, instrument=instrument_name, **kwargs)
        return resp

    def execute_command(self, command, **kwargs):
        status, resp = self.service(command=command, **kwargs)
        return resp.output.strip()

    def write_binary_file(self, command, file_name, **kwargs):
        status, resp = self.service(command=command, binary_file_name=file_name, **kwargs)

    def queue_command(self, command):
        self.command_queue = self.command_queue + [command]

    def execute_queued_commands(self, **kwargs):
        status, resp = self.service(multiple_commands=self.command_queue, **kwargs)
        self.command_queue = []
        return resp.output.strip()

    def set_and_read_command(self, command, set_value):
        set_cmd = command + " " + str(set_value)
        read_cmd = command + "?"
        return self.execute_command(set_cmd + ";" + read_cmd, read = True)

    def read(self):
        status, resp = self.service(doread=True)
        return resp.output.strip()

    def read_error(self):
        status, resp = self.service(unstack_errors=True)
        return resp.output.strip()

    def _parse_float_output(self, output):
        values_string = output.split(',')
        values = ()
        for value_str in values_string:
            values = values + (float(value_str),)
        return values

    def reset(self):
        self.execute_command('*RST', timeout=10.0)
        self.instrument_reset()

    def instrument_reset(self):
        pass

class LossCompensation(object):

    def __init__(self):
        self.loss = 0.0

    def set_loss(self, value):
        self.loss = value

    def compensate(self, value):
        if value < -100:
            self.logger.debug("Compensating path loss with a very small value (%.2f)" % value)
        return value + self.loss

LTE_BW_STRING = {5:'B5M', 10:'B10M', 15:'B15M', 20:'B20M'}
class KeysightEXASpectrumClient(VISAServiceClient, LossCompensation):

    def setup_attenuation(self, mech_atten=30, elec_atten=0):
        self.queue_command(':INIT:CONT ON')
        self.queue_command(':SENS:POW:RF:EATT %s' % str(elec_atten))
        self.queue_command(':SENS:POW:RF:ATT %s' % str(mech_atten))

        self.execute_queued_commands()

    def instrument_reset(self):
        #atten = 0
        #SOME_VALUE = 7
        #while atten != SOME_VALUE:
        #    self.execute_command(':SENS:POW:RF:ATT %s' % str(SOME_VALUE))
        #    atten = self.execute_command(':SENS:POW:RF:ATT?', doread=True)

        self.setup_attenuation()

##region LTE



    def setup_lte_dl_chpower(self, lte_bw=5, **kwargs):
        self.setup_lte_dl_mode(lte_bw=lte_bw, mode='ACP', **kwargs)

    def setup_lte_dl_mode(self, lte_bw=5, mode='ACP', cont='OFF'):
        lte_bw = LTE_BW_STRING[lte_bw]

        self.queue_command(':INIT:CONT %s' % cont)
        self.queue_command(':INST LTE')
        self.queue_command(':CONF:%s' % mode)
        self.queue_command(':INIT:%s' % mode)
        self.queue_command(':%s:AVER:COUN 50' % mode)
        self.queue_command(':RAD:STAN:PRES ' + str(lte_bw))   # LTE bandwidth
        self.queue_command(':RAD:STAN:DIR DLIN')        # downlink

        self.execute_queued_commands()

    def read_evm(self):
        self.queue_command('*TRG')
        self.queue_command(':READ:CEVM?')
        self.execute_queued_commands(doread=True)

    def fetch_evm(self):
        self.queue_command(':FETCH:CEVM?')
        output = self.execute_queued_commands(doread=True)
        return self._parse_float_output(output)[0]

    def fetch_freq_error(self):
        self.queue_command(':FETCH:CEVM?')
        output = self.execute_queued_commands(doread=True)
        return self._parse_float_output(output)[12]

    def read_aclr(self):
        self.queue_command('*TRG')
        self.queue_command(':READ:ACP?')
        output = self.execute_queued_commands(doread=True)
        floats = self._parse_float_output(output)
        # (left adjacent carrier aclr, right adjacent carrier aclr) dbc
        return (floats[4],) + (floats[6],)

    def fetch_channel_power(self):
        self.queue_command(':FETCH:ACP?')
        output = self.execute_queued_commands(doread=True)
        return self.compensate(self._parse_float_output(output)[1])

    def fetch_aclr(self):
        self.queue_command(':FETCH:ACP?')        # downlink
        output = self.execute_queued_commands(doread=True)
        floats = self._parse_float_output(output)
        # (left adjacent carrier aclr, right adjacent carrier aclr) dbc
        return (floats[4],floats[6])

    def fetch_avg_aclr(self):
        aclr = self.fetch_aclr()
        return (aclr[0] + aclr[1])/2.0

    def find_stable_aclr(self):
        # Wait for ACLR to stabilize
        def get_aclr():
            aclr = self.read_aclr()
            return (aclr[0] + aclr[1])/2.0

        return utils.stabilize_output(get_aclr, stable_diff=0.3, poll_rate=0, timeout=20, logger=self.logger)

##endregion

    def setup_find_power_peak(self):
        self.queue_command(':INIT:CONT ON')
        self.queue_command(':INST SA')#Spectrum analyzer
        self.queue_command(':CONF:SAN')
        self.queue_command(':INIT:SAN')

        self.execute_queued_commands()

    def setup_measurement(self, center_freq_mhz=1000, span_mhz=20, ref_level_dbm=20, attn=0):
        self.queue_command(':FREQ:CENT ' + str(center_freq_mhz) + ' MHz')
        #self.queue_command(':DISP:CHP:VIEW:WIND:TRAC:Y:RLEV ' + str(ref_level_dbm) + ' dBm')   # reference level
        #self.queue_command(':POW:ATT ' + str(attn))               # attenuation
        self.queue_command(':FREQ:SPAN ' + str(span_mhz) + ' MHz')     # frequency span

        self.execute_queued_commands()

    def find_peak_stable_freq(self, *args, **kwargs):
        return self._find_peak_stable(0, *args, **kwargs)

    def find_peak_stable_amp(self, *args, **kwargs):
        return self._find_peak_stable(1, *args, **kwargs)

    def _find_peak_stable(self, index, stable_diff, max_freq_error=1000):
        def _get_value():
            peak = self.find_peak()
            if peak is None:
                return -100
            return peak[index]

        peak_amp = utils.stabilize_output(_get_value, stable_diff=stable_diff, average_count=3)
        return self.get_peak_freq(), peak_amp


    def find_peak(self):
        self.execute_command(':CALC:MARK1:MAX')

        return (self.get_peak_freq(), self.get_peak_amp())

    def get_peak_freq(self):
        freq = self.execute_command(':CALC:MARK1:X?', doread=True)
        return float(freq)

    def get_peak_amp(self):
        ampl = self.execute_command(':CALC:MARK1:Y?', doread=True)
        return self.compensate(float(ampl))

    def get_peak_stable_amp(self, stable_diff):
        def _get_value():
            peak = self.get_peak_amp()
            if peak is None:
                return -100
            return peak

        peak = utils.stabilize_output(_get_value, stable_diff=stable_diff, average_count=3)
        return peak

class KeysightEXGGeneratorClient(VISAServiceClient, LossCompensation):

    def setup_lte_waveform_from_file(self, waveform_file, *args, **kwargs):
        _keysight_exg_get_file_header(waveform_file)
        self.write_binary_file(':MEM:DATA "WFM1:ETM_TEST",', waveform_file)
        self.read_error()
        self.setup_waveform_in_gen("WFM1:ETM_TEST", *args, **kwargs)

    def setup_waveform_in_gen(self, waveform_name):
        self.execute_command(':MEM:COPY "%s", "WFM1:TEMP"' % waveform_name)
        self.read_error()

        self.queue_command(':RAD:ARB:WAV "WFM1:TEMP"')
        self.queue_command(':RAD:ARB:RSC 25')#Runtime scaling set to 25%
        self.queue_command(':RAD:ARB ON')
        self.execute_queued_commands(timeout=10)

    def set_arb_sample_clock(self, sample_mhz):
        self.execute_command(':RADio:ARB:SCLock:RATE %sMHz' % str(sample_mhz))

    def setup_output(self, center_freq_mhz=1000, power_dbm=-40):
        compensated_power = self.compensate(power_dbm)
        self.queue_command(':FREQ ' + str(center_freq_mhz) + ' MHz')
        self.queue_command(':POW ' + str(compensated_power) + ' dBm')
        self.execute_queued_commands()

    def output_enable(self, enable, mod_enable=True):
        ON_OFF = {False: 'OFF', True: 'ON'}
        rf_enable = ':OUTP ' + ON_OFF[enable]
        mod_enable = ':OUTP:MOD ' + ON_OFF[mod_enable]

        self.queue_command(rf_enable)
        self.queue_command(mod_enable)
        self.execute_queued_commands()
