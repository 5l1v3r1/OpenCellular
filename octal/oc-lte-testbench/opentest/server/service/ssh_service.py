from base import *
import paramiko
import socket
import time

class SSHServiceConfig():
    def __init__(self):
        self.addr = ""
        self.username = ""
        self.password = ""
        self.create_timeout = 15
        self.port = 22

class SSHServiceRequest():
    def __init__(self):
        self.command = ""
        self.timeout = -1

class SSHServiceResponse():
    def __init__(self):
        self.output = ""
        self.exit_code = 0

SSH_SERVICE_UUID = "ssh"

class SSHService(Service):
    def __init__(self, url, **kwargs):
        Service.__init__(self, url, **kwargs)
        self.ssh = None
        self.addr = None
        self.username = None
        self.password = None

    def service_config(self, config):
        self.addr = self.extract_param(config, "addr")
        self.username = self.extract_param(config, "username")
        self.password = self.extract_param(config, "password")
        self.create_timeout = self.extract_param(config, "create_timeout", default=3)
        self.port = self.extract_param(config, "port", default=22)
        self.connect()

    def connect(self):
        self.logger.debug("Initiating SSH connection at %s", self.addr)
        try:
            self.ssh = paramiko.SSHClient()
            self.ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            self.ssh.connect(self.addr, port=self.port, username=self.username, password=self.password, timeout=self.create_timeout)
            self.ssh.get_transport().set_keepalive(5) #Send keepalive packet every 5 seconds
        except Exception as e:
            raise ServiceError("Unable to connect to SSH host: " + e.message)

    def is_connected(self):
        if self.ssh is None or self.ssh.get_transport() is None:
            return False
        else:
            return self.ssh.get_transport().is_active()

    def try_close(self):
        try:
            self.quick_log("Closing SSH connection")
            self.ssh.close()
        except:
            pass

    def ssh_client_connected(function):
        def check_connected(*args, **kwargs):
            _self = args[0]
            if not _self.is_connected():
                _self.logger.info("Connection is no longer alive")
                _self.connect()
            return function(*args, **kwargs)

        return check_connected

    @ssh_client_connected
    def service_handle(self, request):

        command = self.extract_param(request, "command", default="")
        timeout = self.extract_param(request, "timeout", default=10)
        stdin_list = self.extract_param(request, "stdin", default=[])
        get_pty = self.extract_param(request, "get_pty", default=False)

        output = ""
        err_output = ""
        exit_code = 0
        if command != "":
            self.quick_log("Timeout %.1fs, TTY=%s. Command: %s" % (timeout, str(get_pty), command))
            ssh_stdin, ssh_stdout, ssh_stderr = self.ssh.exec_command(command, timeout=timeout, get_pty=get_pty)

            for stdin_element in stdin_list:
                self.quick_log("> %s" % stdin_element)
                ssh_stdin.write('%s\n'%stdin_element)
                ssh_stdin.flush()

            ssh_stdin.close()# Sends eof

            try:
                self.wait_stdout_with_timeout(ssh_stdout, timeout)
            except socket.timeout:
                self.quick_log("SSH TIMEOUT REACHED")
            finally:
                if(ssh_stdout.channel.exit_status_ready()):
                    exit_code = ssh_stdout.channel.recv_exit_status()
                else:
                    exit_code = 0
                ssh_stdout.channel.close()
                ssh_stderr.channel.close()
                output = ssh_stdout.read()
                err_output = ssh_stderr.read()

            self.logger.debug("Exit code= %d" % exit_code)

            if output != '':
                self.logger.debug(output.strip())
            if err_output != '':
                self.logger.debug("(STDERR)%s" % err_output.strip())

        else:
            self.quick_log("No command specified")
        resp = SSHServiceResponse()
        resp.output = err_output + '\n' + output
        # Clean string of unwanted chars
        resp.output = resp.output.decode('utf-8').encode('ascii','ignore')
        resp.exit_code = exit_code
        return resp

    def wait_stdout_with_timeout(self, stdout, timeout_seconds):
        start_time = time.time()
        while time.time() - start_time < timeout_seconds:
            if stdout.channel.eof_received:
                break
            time.sleep(0)
        else:
            #Timeout condition, close channel before reading
            self.logger.info("COMMAND TIMEOUT REACHED")

    def stream_poll(self, request):
        raise NotImplementedError

    def service_shutdown(self):
        self.try_close()

    @staticmethod
    def service_uuid():
        return SSH_SERVICE_UUID

class SSHServiceClient(ServiceClient):

    def create_service(self, addresseip , username_ssh, password_ssh, timeout=15):
        status, resp = self.new_service(uuid = SSHService.__name__, addr=addresseip, username=username_ssh, password = password_ssh, create_timeout=timeout)
        assert status < 400

    def execute_command(self, cmd, assertexitcode=0, **kwargs):
        output, exit_code = self.execute_command_output_status(cmd, **kwargs)
        if assertexitcode is not None and exit_code != assertexitcode:
            simple_error = "[%s] returned exit code %d, expected %d" % (cmd.strip(),exit_code, assertexitcode)
            if output.strip():
                complex_error = "%s\n%s" % (simple_error, output.strip())
            else:
                complex_error = simple_error
            self.logger.info(complex_error)
            assert exit_code == assertexitcode, simple_error
        return output

    def execute_command_status(self, cmd, **kwargs):
        output, exit_code = self.execute_command_output_status(cmd, **kwargs)
        return exit_code

    def execute_command_output_status(self, cmd, **kwargs):
        status, resp = self.service(command=cmd, **kwargs)
        return resp.output,resp.exit_code

    def does_file_or_folder_exists(self,path):
        if self.does_file_exists(path):
            return 1
        elif self.does_folder_exists(path):
            return 2
        else:
            return 0

    def does_file_exists(self, file_path):
        return self._does_exists_arg("f", file_path)

    def does_folder_exists(self, folder_path):
        return self._does_exists_arg("d", folder_path)

    def _does_exists_arg(self, arg, path):
        str_test_file = "test -%s %s ; echo $?" % (arg, path)
        #success == 0 if file exists
        success = int(self.execute_command(str_test_file))
        #Invert to return true if success = 0
        return not bool(success)

    def read_file(self, path):
        read = self.execute_command("cat %s" % path,assertexitcode=None)
        return read

    def write_file(self, path, content):
        self.execute_command("echo \"%s\" > %s" % (content, path))
