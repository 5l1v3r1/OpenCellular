
from Queue import Queue, Empty
import threading
import time
from serial import Serial
import paramiko



class IOInterface():

    def __init__(self, *args, **kwargs):
        pass

    def io_read(self):
        raise NotImplementedError

    def io_write(self, data):
        raise NotImplementedError

    def close(self):
        pass

class COMInterface(IOInterface):

    def __init__(self, port, baudrate):
        self.serial = Serial(port=port, baudrate=baudrate, timeout=0.05)

    def io_read(self):
        read_value = self.serial.read()
        return read_value.decode('utf-8','ignore').encode("utf-8")

    def io_write(self, data):
        data = data.encode('ascii','ignore')
        return self.serial.write(data)

    def close(self):
        self.serial.close()

class SSHInterface(IOInterface):

    def __init__(self, addr, login, password):
        self.ssh = paramiko.SSHClient()
        self.ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        self.ssh.connect(addr, username=login, password=password)
        self.channel = self.ssh.get_transport().open_channel("session")

    def io_read(self):
        return self.channel.recv(2048)

    def io_write(self, data):
        return self.channel.send(data)

    def close(self):
        self.ssh.close()

class IOInterfaceDaemon():
    def __init__(self):
        self.read_queue = Queue()
        self.write_queue = Queue()
        self.interface = None
        self.reader_thread = None
        self.writer_thread = None

    def start(self, interface):
        self.interface = interface
        self.reader_thread = IOReaderThread(self, self.interface, self.read_queue)
        self.reader_thread.setDaemon(True)
        self.reader_thread.start()

        self.writer_thread = IOWriterThread(self, self.interface, self.write_queue)
        self.writer_thread.setDaemon(True)
        self.writer_thread.start()

    def get_interface(self):
        return self.interface

    def write_async(self, data):
        self.write_queue.put(data)

    def read_async(self, timeout=None):
        result = ""
        try:
            result = self.read_queue.get(timeout=timeout)
        except Empty:
            pass
        return result

    def is_read_data_available(self):
        return not self.read_queue.empty()

    def get_approx_read_data_available(self):
        return self.read_queue.qsize()

    def kill(self):
        if self.writer_thread is not None:
            self.writer_thread.kill_thread()
        if self.reader_thread is not None:
            self.reader_thread.kill_thread()
        if self.interface is not None:
            self.interface.close()

class IOReaderThread(threading.Thread):

    def __init__(self, daemon, interface, queue):
        threading.Thread.__init__(self)
        self.interface = interface
        self.queue = queue
        self.run_flag = True
        self.daemon = daemon

    def read_callback(self, read):
        pass

    def run(self):
        string = ""
        while self.run_flag:
            d = self.interface.io_read()

            if d is not "":
                string += str(d)

            if (d is "" or '\n' in string) and len(string) > 0:
                self.queue.put(string)
                self.read_callback(string)
                string = ""
                time.sleep(0)

    def kill_thread(self):
        self.run_flag = False

class IOWriterThread(threading.Thread):

    def __init__(self, daemon, interface, queue):
        threading.Thread.__init__(self)
        self.interface = interface
        self.queue = queue
        self.run_flag = True
        self.daemon = daemon

    def write_callback(self, written):
        pass

    def run(self):
        while self.run_flag:
            while not self.queue.empty():
                c = self.queue.get()
                self.interface.io_write(c)
                self.write_callback(c)
            time.sleep(0)
        self.end_flag = True

    def kill_thread(self):
        self.run_flag = False
