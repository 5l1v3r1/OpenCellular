
import logging
"""
@click.group(help="This file contains functions to control the Mini-Circuit 8SPDT-A18 Switch")
def group_entry():
    pass

##region create(serverport, switch_id, )

@group_entry.command('create', help="before any other function")
@click.argument('serverport')
@click.argument('com')
@click.argument('baudrate')
def _cmd_create(*args, **kwargs):
    create(*args, **kwargs)

@utils.capture_print
def create(serverport, com, baudrate):
    with COMServiceClient(url=com, ip="127.0.0.1", port=serverport) as client:
        client.create_service(com, baudrate)

##endregion create(serverport, com)
"""

class SwitchMatrix():
    def __init__(self, logger=None):
        self.switches = {}
        self.graph = {}
        if logger is not None:
            self.logger = logger
        else:
            self.logger = logging.getLogger('switch_matrix')

    def parse_ini_file(self, file_path):
        with open(file_path) as f:
            self.parse_ini_string(f.read())

    def parse_ini_string(self, string):
        import ConfigParser
        import StringIO
        buf = StringIO.StringIO(string)
        config = ConfigParser.SafeConfigParser()
        config.optionxform = str
        config.readfp(buf)

        for section in config.sections():
            switch_name = section
            switch = SimpleSwitch(switch_name)
            for name, value in config.items(section):
                if name.upper() != 'COM':
                    switch.add_port(name)

            switch = self.update_switch(switch)

            for name, value in config.items(section):
                self.add_new_link(switch.get_full_port_name(name), value)
        self.add_missing_switches_nodes()

    def add_missing_switches_nodes(self):
        """
        Loops through the whole graphs and searches for switch's ports that were added but that are not linked to the switch COM.
        """
        for node, value in self.graph.iteritems():
            switch_name = self.get_switch_from_port_name(node)
            port_name = self.get_port_from_full_port_name(node)
            if switch_name:
                switch = self.switches[switch_name]
                switch.add_port(port_name)
                self.update_switch(switch)


    def update_switch(self, switch):
        self.combine_graphs(switch.node)
        self.switches[switch.name] = switch
        return switch

    def combine_graphs(self, graph_to_append):
        for node, value in graph_to_append.iteritems():
            if node not in self.graph:
                self.graph[node] = value
            else:
                self.graph[node] = self.combine_tuple_no_duplicate(self.graph[node], value)

    def combine_tuple_no_duplicate(self, tuple1, tuple2):
        return tuple1 + tuple(set(tuple2) - set(tuple1))

    def add_new_link(self, a, b):
        switch_a = self.get_switch_from_port_name(a)
        switch_b = self.get_switch_from_port_name(b)

        if switch_a == switch_b:
            if switch_a == None:
                raise ValueError("Trying to link two external nodes that do not pass through the switch.")
            else:
                raise ValueError("Trying to link a switch with itself")

        self._add_half_link(a,b)
        self._add_half_link(b,a)

    def _add_half_link(self, a, b):
        if a in self.graph:
            self.graph[a] = self.graph[a] + (b,)
        else:
            self.graph[a] = (b,)

    def find_shortest_path(self, start, end, path=[]):
        path = path + [start]
        graph = self.get_graph_for_path(path)
        if start == end:
            return path

        if not graph.has_key(start):
            return None
        self.logger.debug(start)
        shortest = None
        for node in graph[start]:
            if node not in path:
                newpath = self.find_shortest_path(node, end, path)
                if newpath:
                    if not shortest or len(newpath) < len(shortest):
                        shortest = newpath
        return shortest

    def get_graph_for_path(self, path):
        graph = self.graph.copy()
        previous_switch = 'some random,impossible switch name'
        for node in path:
            switch = self.get_switch_from_port_name(node)
            port = self.get_port_from_full_port_name(node)
            if port == "COM" and switch == previous_switch:
                #Remove links from x.COM to x.PORTy
                self.remove_links_to_switch_from_node(node, switch, graph)
            previous_switch = switch
        return graph


    def remove_links_to_switch_from_node(self, node, switch_name, graph):
        new_tuple = ()
        for old_value in graph[node]:
            switch = self.get_switch_from_port_name(old_value)
            if switch != switch_name:
                new_tuple = new_tuple + (old_value,)

        graph[node] = new_tuple

    def get_actions_for_path(self, start, end):
        #Start with None action (no action required)
        #All switches present
        actions = dict.fromkeys(self.switches)
        self.logger.debug("Searching path")
        shortest_path = self.find_shortest_path(start, end)
        if shortest_path == None:
            message = "Path does not exists"
            if start not in self.graph:
                message = message + ": start point %s does not exists" % start
            if end not in self.graph:
                message = message + ": end point %s does not exists" % end
            raise ValueError(message)

        previous_switch = ''
        current_switch = None
        previous_node = None
        for node in shortest_path:
            current_switch = self.get_switch_from_port_name(node)
            if current_switch == previous_switch:
                #Internal switch path: action required
                actions[current_switch] = self.get_switch_action(current_switch, node, previous_node)

            previous_switch = current_switch
            previous_node = node


        return actions

    def __str__(self):
        string = []
        for key, value in self.graph.iteritems():
            string.append("%-10s -> %s" %(key, str(value)))
        return '\n'.join(sorted(string))

    def get_switch_action(self, switch_name, node, previous_node):
        switch_object = self.switches[switch_name]
        try:
            action = switch_object.get_switch_action(node)
        except ValueError:
            action = switch_object.get_switch_action(previous_node)

        return action


    def get_switch_from_port_name(self, port_name):
        return self.get_split_name(port_name, 0)

    def get_port_from_full_port_name(self, port_name):
        return self.get_split_name(port_name, 1)

    def get_split_name(self, port_name, split_index):
        #Switch port A.PORT1
        #Other port SPECTRUM (no dot)
        split_str = port_name.split('.')
        if len(split_str) < 2:
            #Not a switch port
            return None
        else:
            return split_str[split_index]

    def get_switches(self):
        for switch in self.switches:
            yield switch

    def get_numb_switch(self):
        return len(self.switches)

    def get_name_port(self):
        for key, value in self.graph.iteritems():
            if self.get_port_from_full_port_name(key) == None:
                yield key


class SimpleSwitch():
    def __init__(self, name, *ports):
        self.name = name
        self.com_name = self.name + '.COM'
        self.node = {self.com_name: ()}

    def add_port(self, port):
        new_port = self.get_full_port_name(port)
        if new_port not in self.node:
            unsorted = self.node[self.com_name] + (new_port,)
            self.node[self.com_name] = tuple(sorted(unsorted))
            self.node[new_port] = (self.com_name,)

    def add_ports(self, *ports):
        for port in ports:
            self.add_port(port)

    def get_switch_action(self, port):
        return self.node[self.com_name].index(port)

    def get_full_port_name(self, port):
        return self.name + '.' + port



if __name__ == "__main__":
    # This block pauses the command line when bad arguments are passed or when the
    # main exits early.
    # This is needed when the command line exits after execution, as it gives us
    # time to see the error.
    matrix = SwitchMatrix()
    matrix.parse_ini_string("""
[A]
PORT1: UUT_OUTA
PORT2: B.COM
COM: C.PORT1

[B]
PORT1: UUT_OUTB
PORT2: UUT_OUTB2


[C]
PORT2: E.COM
COM: UUT_COMC

[D]
PORT1: UUT_OUTD
PORT2: UUT_OUTD2
COM: G.PORT1

[E]
PORT1: UUT_OUTE
PORT2: F.COM

[F]
PORT1: UUT_OUTF
PORT2: UUT_OUTF2

[G]
PORT2: H.COM
COM: UUT_COMG

[H]
PORT1: UUT_OUTH
PORT2: UUT_OUTH2
    """)
    print(matrix.get_actions_for_path('F.PORT2', 'F.PORT1'))
