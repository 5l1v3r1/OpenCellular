import os
from base import *
from opentest.integration.calib_utils import PathLosses, SwitchMatrix

IO_RFSWITCH_SERVICE_UUID = "rfswitch"

class RFSwitchServiceConfig():
    def __init__(self):
        self.interface_name = ""

class RFSwitchServiceRequest():

    def __init__(self):
        self.patha = ""
        self.pathb = ""

class RFSwitchServiceResponse():
    '''
    :param read: What was read from switches states
    :param path_option: What option, path can be
    '''
    def __init__(self):
        self.read = ""
        self.path_option = ""
        self.loss = ""

class RFSwitchError(ServiceError):
    pass


#TESTLINE

class RFSwitchService(Service):
    """
    Requires win32com, installer at \\Ravel\r&d\SQA-NPI\Utilitaires\Python\pywin32-221.win32-py2.7.exe
    Requires Mini-circuit ActiveX, installer at \\Ravel\r&d\SQA-NPI\Utilitaires\Python\MiniCircuit_RFSwitch_Installer
    """
    def __init__(self, url, **kwargs):
        Service.__init__(self, url, **kwargs)
        self.switchMatrix = SwitchMatrix(logger=self.logger)
        self.sw1 = ""
        self.switchcount= 0

    def service_config(self, config):
        '''
        The service_config will take ini as a configuration for the switch_graph. The ini can be either a string
        or a file.ini according the value of string_ini : True for sting and False for the latter. The service_config
        nned to reference the DLL (PyWin32). Then it connect the switch via USB port. The number of switches is form the ini.
        '''
        string_ini = self.extract_param(config, "string_ini", default=False)
        self.logger.debug("Configuring switchs path")
        ini = self.extract_param(config, "ini")

        if string_ini:
            self.switchMatrix.parse_ini_string(ini)
        else :
            self.switchMatrix.parse_ini_file(ini)
        self.logger.debug("Path set up as follow: \n" + str(self.switchMatrix))
        self.logger.debug("trying to connect to the switchs")
        # Reference the DLL
        import win32com.client # Reference PyWin32
        import pythoncom
        self.sw1 = win32com.client.Dispatch("MCL_RF_Switch_Controller.USB_RF_Switch")
        self.connect_switchs()
        self.switchcount= self.switchMatrix.get_numb_switch()
        self.quick_log('SUCCESS')

    def service_handle(self, request):
        '''
        Handle all the request here :

        -       "reset" : Will set up all the switches to 0.
        -       "read"  : Will read the current value of all the switches.
        -        "info"  : Will return names of the possible paths

        Else enter "patha" and "pathb" : Will set the switches according to the switch graph (service_config)
                                         Then return the value of the switches.
                                         Will failed if there is no possible path.
        '''

        resp = RFSwitchServiceResponse()
        reset = self.extract_param(request, "reset", default=False)
        read = self.extract_param(request, "read", default=False)
        info = self.extract_param(request, "info", default=False)

        if reset or read or info:
            if reset:
                self.reset_all_switch()
            if read:
                resp.read = self.read_current_switches()
            if info:
                resp.path_option = self.return_end_point()

        else:
            patha = self.extract_param(request, "patha")
            pathb = self.extract_param(request, "pathb")

            if (patha is not None and pathb is not None):
                self.logger.debug("Finding path from " + patha + " to " + pathb)
                self.quick_log("LINK " + patha + "<->" + pathb)
                resp.read = self.setup_all_switchs(patha, pathb)
            else:
                raise Exception("A path may not be None")
                #resp.data = self.setup_all_switchs(patha, pathb)
        return resp

    def get_actions_for_path(self, patha, pathb):
        '''
        Check what action to take if there is a way. Return the path.
        '''
        return self.switchMatrix.get_actions_for_path(patha, pathb)

    def setup_all_switchs(self, patha, pathb):
        '''
        Set the switches according to the actions get for the path.
        Return the value of the switches after setting them.
        '''
        self.actions = self.get_actions_for_path(patha, pathb)
        self.logger.debug(self.actions)

        for switch_letter, state in self.actions.iteritems():
            self.control_switchs(switch_letter, state)

        # Display the new states of all switches
        return self.read_current_switches()

    def reset_all_switch(self):
        '''
        Set all the switches to their default value, 0.
        '''
        for switch_name in self.switchMatrix.get_switches():
            self.control_switchs(switch_name, 0)

    def control_switchs(self, sw_name, sw_state):
        # Set the switch
        if sw_state is not None:
            self.logger.debug('%s set to %d' % (sw_name, sw_state))
            self.sw1.Set_Switch(sw_name, sw_state)

    def read_current_switches(self):
        '''
        Return the value of all the switches
        '''
        set_state = 0
        read_sw = self.sw1.GetSwitchesStatus(set_state)
        return self._interpret_switch_port(read_sw[1], 8)

    def _interpret_switch_port(self, sw_port, noswitches):
        '''
        Converts decimal switch port value into bits, each indicating a switch state
        NoSwitches should be set to the number of switches available (eg: 3 for RC-3SPDT-A18)
        '''
        last_remainder = int(sw_port)
        sw_state = int(0)
        this_remainder = int(0)
        first_loop = True
        sw_state_list = []
        # Loop for each switch
        for n in range(int(noswitches), -1, -1):

            # Calculate each switch state by comparing to the byte value and the previous states
            this_remainder = last_remainder - (sw_state * (2**(n+1)))
            sw_state = int(this_remainder / 2**n)
            last_remainder = this_remainder
            if first_loop == False: # Ignore the first pass as it doesn't relate to a switch
                sw_state_list.append(sw_state) # Add each switch state to a list
            first_loop = False
        return sw_state_list


    def connect_switchs(self):
        '''
        Check if it is possible to connect. Will failed if called multiple time wihout closing.
        '''
        # Connect to the switch
        conn_Status = self.sw1.Connect()
        # Carry out switching routine if connection was successful
        if conn_Status == 1:# 0: not connected and >1 : multiple connection
            self.logger.info("Connection sucessful")
        else:
            raise Exception("Could not connect")

    def disconnect_switchs(self):
        self.sw1.Disconnect

    def return_end_point(self):
        '''
        Return name found in the ini for service_config
        '''
        full_string = ""
        for name in self.switchMatrix.get_name_port():
            full_string = (full_string + str(name) +" ")
        return full_string

    def service_shutdown(self):
        '''
        Everything that need to be done when service end.
        '''
        self.disconnect_switchs()

    @staticmethod
    def service_uuid():
        return IO_RFSWITCH_SERVICE_UUID

class RFSwitchServiceClient(ServiceClient):

    def create_service(self, path_file): #type_ini: None = file.ini
        abspath = os.path.abspath(path_file)
        return self.new_service(uuid=RFSwitchService.__name__, string_ini=False, ini=abspath)

    def set_switch_path(self, patha, pathb):
        return self.service(patha=patha, pathb=pathb)

    def read_state_switches(self):
        return self.service(read=True)

    def reset(self):
        self.service(reset=True)

    def path_option(self):
        return self.service(info=True)

class LossRFSwitchServiceClient(RFSwitchServiceClient):

    def __init__(self, *args, **kwargs):
        self.loss = PathLosses()
        RFSwitchServiceClient.__init__(self, *args, **kwargs)

    def create_service(self, path_file, loss_file=None): #type_ini: None = file.ini
        if loss_file:
            self.load_loss_from_file(loss_file)

        return RFSwitchServiceClient.create_service(self, path_file)

    def set_switch_path(self, patha, pathb):
        self.service(patha=patha, pathb=pathb)
        return self.loss.get_key(patha, pathb)

    def add_loss(self, key, value):
        loss = self.loss.get_loss_key(key)
        return value + loss

    def load_loss_from_file(self, path_file):
        return self.loss.load_from_file(path_file)
