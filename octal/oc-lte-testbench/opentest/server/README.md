
# Running the server
## Command line  
The server is launched using the server_main file and implements a  `__main__` file to be able to launch the package directly. There are two launching commands: start and launch.  

### Start  
Starts the server in the current process.  
`opentest.server start 5000 [-n NAME]`  
	-n, --name: the name of the server, by default anonymous.  

### Launch  
Starts the server in a separate process.  
`opentest.server launch 5000 [-n NAME]`  
	-n, --name: the name of the server, by default anonymous.  

## From python  
If launching the server from python, use the `serverinterface` module.

### ServerInterface

`ServerInterface` holds information about a remote (or local) server and allows execution of basic server-related functions such as:
- `set_log_destination(destination)` Sets the default log destination on shutdown. This can be set at the beginning of a test and if the server is unexpectedly shutdown (ctrl^c or other), logs will be nonetheless copied to this location.
- `shutdown_request(move_logs="")` Request shutdown of the server. if move_logs is specified, the logs will be moved to that location. This destination supersedes any previous `set_log_destination` calls.
- `openlogs_request()` Request the opening of LogExpert with the current active logs.
- `is_alive()` Returns whether or not this server responds
- `config_request(content)` Call to server configuration route with content
- `shell_request(url, msg)` Call a shell service at `url` with `msg`.

### LaunchedServerInterface

`LaunchedServerInterface` is a child of `ServerInterface`. This `ServerInterface` is meant to launch a new server and instantiate clients based on a server.ini file.  
This is an abstract class, it requires an implementation of `launch_server`. The only current implementation is `LocalLaunchedServerInterface`, which forces the use of the `127.0.0.1` address and launches the server by creating a new process with the `server_main start` command.  

**Without `server.ini`**

```python
import serverinterface
#Launch the server without a server.ini file
server = serverinterface.LocalLaunchedServerInterface(port=5000, name='testbench')

## Using a client of this server
client = COMServiceClient(url='comport', port=5000)
client.create_service('COM6', baudrate=115200)
```

**With `server.ini`**  
Here is an example of `server.ini`:  
```
[SERVER]
ADDR: '127.0.0.1'
NAME: "oc-lte-base-board"
PORT: 5000
KILL_IN_CLEANUP: False

[SERVICE]
;name: (<url>, <ServiceClass>, <ServiceClientClass>)
com: ('comport', 'COMService', 'COMServiceClient')
ssh: ('ssh', 'SSHService', 'SSHServiceClient')
tftp: ('tftp', 'TFTPService', 'TFTPServiceClient')
dhcp: ('dhcp', 'DHCPService', 'DHCPServiceClient')
rfswitch: ('rfswitch', 'RFSwitchService', 'RFSwitchServiceClient')
generator: ('generator', 'VISAService', 'KeysightEXASpectrumClient')
spectrum: ('spectrum', 'VISAService', 'KeysightEXGGeneratorClient')
```

```python
import serverinterface

# Launch the server with a server.ini file. No need to specify port if specified in server.ini
server = serverinterface.LocalLaunchedServerInterface(ini_file='server.ini')

## Using a client of this server
# server.com is the equivalent of the following line:
# server.com = COMServiceClient(ip='127.0.0.1', url='comport', port=5000)
# These informations are inferred from the com line of the server.ini file
server.com.create_service('COM6', baudrate=115200)

```

### Command Line Interface  
A CLI can be attached to a `ServerInterface`. Note that one is automatically attached to a server launched with the `start` command (`LocalLaunchedServerInterface` uses this command also)  
The CLI may be remotely instantiated:  

```python
import serverinterface
server = serverinterface.LocalLaunchedServerInterface(ini_file='server.ini')

cli = serverinterface.ServerCLI(server)
#Runs in a separate process
cli.start()
#User can now enter commands in the current command line
#Wait until end of program (ctrl^c)
cli.join()
```

### Usage with TestRunner

If used with the testrunner, the server should be launched at the start using the `nute.core.server_scripts.launch` function:  
```python
from nute.core import server_scripts
	@testrunner.testcase("Launch Service Server", critical=True)
	def TSC000_1(self, context):
		import nute.core.server_scripts as server_scripts
		# context must contain  SERVER_INIT_FILE
		# test.ini:
		# [SERVER]
		# INIT_FILE = 'server.ini'
		server_scripts.launch(context)
		# context.server is the LaunchedServerInterface
```

# Functionnalities

## Request/Response Content
All content is sent and received from the server is currently JSON. The python module jsonutils implements methods to transform an object to json and back. In the following sections, the word argument refers to an attribute of the object received.
```python
#Client side, from dcsupply/exampleclient.py
with ServiceClient(url="test", ip="127.0.0.1", port=5001) as client:
  #Create service
  #The default implementation of ServiceClient creates an object with attributes in kwargs
  status, resp = client.new_service(uuid="dcsupply")

  #Assert no error
  assert status < 400

  #Use service
  #seton True/False, setvout [6-24V]
  resp = client.service(seton=True, setvout=12.0)
  resp.vout #Current vout
  resp.on #is on or not
```
## Internal routes

### Config
*POST /config*  
Server-wide configuration options.
- openlogs_on_new_service : [OPTIONAL] When true, the log monitoring software will be relaunched every time a new service is created (equivalent to a POST to /openlogs)

### Shutdown
*POST /shutdown*  
Any post at url /shutdown will initiate an orderly shutdown of the server.  
- move_logs : [OPTIONAL] Move this server logs to the speficied folder after shutdown.

### Open log monitoring software
*POST /openlogs*  
Any post at url /openlogs will launch baretail.exe with tabs opened of all service logs found in this server's logging folder.

## Service routes
*/service*  
All services routes are under url /service. They all can be accessed by two distinc ways:
 - Using the url (i.e. /service/comtest)
 - Passing an attribute 'url' in the request content at url /service

If the HTTP request url is specified, the 'url' attribute will be ignored.

### New service
*POST /service/url*  
Creates a new service at url. Here is the list of arguments supported:  
 - [REQUIRED] uuid: The string which represents the service which is to be instantiated. The value of this string for a particular service is determined with the value returned by its service_uuid() static method.
 - [OPTIONAL] file_log: True by default, determines if a log file is created for the service.
 - [OPTIONAL] overwrite: False by default, determines if a existing service at the url should be overwritten or not.
 - All other arguments are passed to the new_service method of the Service being created. Each service may require parameters for initialization (I.e. COMService requires a port name and a baudrate)

### Service handling
*PUT /service/url*  

### Service streaming (polling mode)
*PUT /service/url?stream=True*  

## Server Builder (new server.ini)

Usage:  
```python

server = LocalLaunchedServerInterface(ini_file=SERVER_INIT_FILE)
server.open_logs_request()
# If the server.ini file is the preceding example:
server.com.create_service("COM13", baudrate=115200) #COMServiceClient at url comport
# create_service must still be called !
...

server.shutdown_request(move_logs="...")
```



# Possible Ideas

## URL Namespaces for parallel execution of test
Add a layer of service urls such as `/<namespace>/service/...` that would allow the creation of multiple testbenchs on the same service server. Moreover, this would allow a "shared" namespace composed of shared services such as a spectrum or a signal generator. These services would offer locking mechanism. NOTE that the structure of the server would need to be changed to allow parallelism, since right now a single worker exists.

## server.ini and testrunner context integration
**IMPLEMENTED**  
*See Server Builder section*

## Server GUI
A GUI for the server which has the following features:
- A button to openlogs OR integrated log showing tabs
- A button to shutdown the server
- An activity indicator/log of the server
- A button to open a shell command window to the specified service
	- The command window could register a stream handler of level DEBUG to the service logger
	- How to link the python function of the GenericServer with an external process (command line) ?
	- https://sourceforge.net/projects/qconsole/ console for qt
- Add a shutdown feature that resets the server with no services: this would allow to leave the server window open and simply reset all services for the next UUT. Would require some work to replace the logging.shutdown which could not be called anymore to keep the logging alive. Might not be worth it

## Storage service for persistent variable
A service which can store information such as the uut IP addr, MAC addr, serial #, etc. These informations could then be used by the other services instead of always relying on the client to pass these infos. They could be scanned for when required arguments are not present in a service request object.  
I.e. SSH service requires an "ipaddr" argument. If not found in the request object, the extract\_param method would search for a \_\_builtin\_\_.ipaddr, which, if ever received, would have been set by the storage service.

## Streaming services using a Socket.IO/WebSocket server
**CANCELLED**  
*Unable to have reliable websocket connection without long polling. Implemented a polling mechanism instead.*

Connection to server as a WebSocket, then bi-directionnal data can be sent. This means that, for example, IOInterfaceService could send data as soon as it is read directly to the client without the client requesting it. Adding a Listener to IOInterfaceDaemon on read would be a way to use a separate thread (the reader thread) to stream back data to the client

Using Socket.io rooms, the websocket would join the "room" of the service (its url x) and the GenericServer would add a field notifying that a Websocket stream is alive at url x
GenericServer should add a reverse request which could come from a Service, i.e. send_to_client. It would check if the (only) websocket alive is the one at this url. GenericServer should also have a is_websocket_alive(service) to check if the websocket is alive for this service.

Implementation for Flask : https://flask-socketio.readthedocs.io/en/latest/

Client implementation Python : https://pypi.python.org/pypi/socketIO-client
