#!/usr/bin/env python
# -*- coding: utf-8 -*-

import re

# build product dictionary
def product_build_list(path):

    file = open(path,'r')
    filestr = file.read()
    listnotdone = True
    product_start = 0
    product_dict = {'Product':('mrp','path')}
    while listnotdone: #find all production in list
        product_start = filestr.find("[",product_start+1)
        if product_start == -1:
            return product_dict #return if file is finished
        product_end = filestr.find("]",product_start)
        if product_start == -1:
            return product_dict #return if file is finished
        product = filestr[product_start+1:product_end]

        mrp_start=filestr.find("mrp=",product_end)
        mrp_end=filestr.find("folder=",product_end)
        mrp = filestr[mrp_start+4:mrp_end-1]

        path_start=filestr.find("folder=",product_end)
        path_end=filestr.find("[",product_end)
        path = filestr[path_start+7:path_end-1]
        product_dict[product] = (product,mrp,path)

    return product_dict

# build product dictionary and find matching product
def product_find(dict, mrp):

    for key in dict:
        f = mrp.find(dict[key][1])
        if f == 0:  #if mrp matches key
            return key

class Format:
    MRP = ('MRP', r'(PRD-([0-9]+)-(\w+))')
    SN = ('SN', r'(NTQ([0-9]+))')
    MAC_ADDR = ('MAC_ADDR', r'([0-9A-F]{2}[:-]){5}([0-9A-F]{2})')

class UUTError(Exception):
    pass

class UUT:

    SN      = "INVALID SN"
    MRP     = "INVALID MRP"
    Product = "INVALID PRODUCT"
    ProductPath = "INVALID PATH"

    def __init__(self, form=None):
        self.SN = "INVALID SN"
        self._format = None
        if form is not None:
            self.set_format(form)

    def set_format(self, form):
        self._format = form

    def pretty_format(self):
        string = ""
        for attr_name, form in self._format:
            string = string + "%s;" % attr_name
        return string

    # parse uut scan and return
    def scan_parse(self, scan):
        if self._format is None:
            return self.old_scan_parse(scan)

        values = scan.split(';')
        for expected_format, value in zip(self._format, values):
            attr_name, form = expected_format
            try:
                setattr(self, attr_name, re.search(form, value).group(0))
            except AttributeError:
                raise UUTError('Error while matching %s to %s. %s is not a %s' % (scan, self.pretty_format(), value, attr_name))
            replaced_value = re.sub(form, '', value)
            if replaced_value != '':
                raise UUTError('Error while matching %s to %s. %s matches, but not completely (%s left)' % (scan, self.pretty_format(), value, replaced_value))

        if len(self._format) != len(values):
            raise UUTError('Error while matching %s to %s. Number of fields incompatible.' % (scan, self.pretty_format()))

    def old_scan_parse(self, scan):
        if scan == "":
            ret = "EMPTY SCAN"
            return ret
        ret = "OK"
        line = scan.split(';')
        if len(line) == 2:
            if len(line[0]) < 13:
                ret =  "BAD MRP FORMAT"
            if len(line[1]) != 10:
                ret =  "BAD SERIAL NUMBER FORMAT"
            self.MRP = line[0]
            self.SN = line[1]
        else:
            ret = "INVALID SCAN"
            return ret

        products = product_build_list("//ravel/Production/Outils/ConfigFiles/products.ini")
        key_id = product_find(products, self.MRP)
        self.Product =  products[key_id][0]
        self.Path =  products[key_id][2]
        return "OK"
