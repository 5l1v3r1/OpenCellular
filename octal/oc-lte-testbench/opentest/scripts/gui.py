
from Tkinter import *
from ttk import Combobox, Checkbutton, Scrollbar, Style
from ttk import Button as ttkButton
from tkMessageBox import *
import tkSimpleDialog
import sys
import time
import os
import opentest
import testrunner as testrunner

from threading import Thread

main_window = Tk()
main_window.title("TESTING IN PROGRESS")
main_window.resizable(width=False, height=False)
#main_window.geometry('{}x{}'.format(1600, 900))

ABOUT_TEXT = """About

2017-11-09 (Last update)

."""

DISCLAIMER = """
Disclaimer

"""

class gui(testrunner.TestRunnerInterface):
    def __init__(self, package_path, scan_message, log_level):
        self.path = package_path
        self.scan_message = scan_message
        self.logging_info = log_level
        self.window_open = False
        self.unit_code = ""
        self.critical_fail=False
        self.test_result_passed=[]
        self.test_result_failed=[]
        self.test_result_not_executed=[]
        self.test_name = []
        self.list_log_thread=[]
        self.time_start=0
        self.time_end=0

    def testme(self):
        s=Style()
        print(s.theme_names())
        s.theme_use('vista')

    def testrunner_setup(self):
        self.testrunner = testrunner.TestRunner(self.path, scan_message= self.scan_message, log_level= self.logging_info, test_interface =self)
        self.testrunner_info=self.testrunner.prepare_test()
        #print self.testrunner_info.lookup_file
        #print self.testrunner_info.lookup_section
        #print self.testrunner_info.batch_file
        #print self.testrunner_info.test_config_files
        #print self.testrunner_info.criteria_files
        #print self.testrunner_info.testrunner
        self.Temp_name_fn()
        self.button_run.configure(state=NORMAL)

    def get_logging_stream(self):
        #print("o")
        return sys.stderr

    def get_unit_code(self, context, message):
        return self.scan_unit()

    def wait_tester_feedback(self, context, message):
        self.resp = False
        self.text_cmd.config(state=NORMAL)
        self.text_cmd.insert(END, message+">\n ")
        self.text_cmd.see(END)
        self.text_cmd.config(state=DISABLED)
        def enter_cmd():
            self.resp=True
            tester_input=self.entry_cmd.get()
            self.entry_cmd.delete(0, "end")
            self.text_cmd.config(state=NORMAL)
            self.text_cmd.insert(END, tester_input+"\n> ")
            self.text_cmd.see(END)
            self.text_cmd.config(state=DISABLED)

            #tester_input = self.yesno_tester_feedback(message=message)
            try:
                context.logger.debug("Tester entered [%s]" % repr(tester_input))
                if tester_input.strip().lower() == "n":
                    raise TesterInterruption(message)
            except TesterInterruption:
                raise

        def e_enter_cmd(event):
            enter_cmd()
            self.resp=True

        self.entry_cmd.bind("<Return>", e_enter_cmd)
        self.button_cmd.configure(command= enter_cmd)
        i=0
        while not self.resp:
            pass


    def test_started(self, context, test_function):
        self.advancement_status_update(test_function, "Running")

    def test_passed(self, context, test_function):
        self.advancement_status_update(test_function, "Passed")

    def test_failed(self, context, test_function):
        self.advancement_status_update(test_function, "Failed")
        if test_function.critical:
            self.critical_fail=True

    def test_done(self, context):
        self.time_end=time.time()
        self.button_result.configure(state=NORMAL)
        self.label_test_status_value.config(text="FINISH",fg="green")

    def setup_interface(self):
        #CMD Section setup
        self.scrollbar_cmd = Scrollbar(main_window)
        self.canvascmd = Canvas(main_window,width=800, height=200, bg="darkgray")
        self.text_cmd= Text(self.canvascmd, wrap=WORD, yscrollcommand=self.scrollbar_cmd.set, width=130, height=16, fg="white", bg="black", font=("Consolas", 11), bd=4)
        self.scrollbar_cmd.config(command=self.text_cmd.yview)
        self.text_cmd.insert(END, "C:\GIT_Files\oc-lte-testbench> ")
        self.text_cmd.config(state=DISABLED)

        #Log Temp Section, get overwrite by Thread
        self.scrollbar_log = Scrollbar(main_window)
        self.canvaslog = Canvas(main_window,width=800, height=400, bg="grey")

        #Test Status Setup
        self.canvas_advancement= Canvas(main_window, width=500, height=550, bg="darkgray", relief=RIDGE, bd=6)
        self.Scrollbar_advancement = Scrollbar(main_window)

        #Serial Number section
        self.entry_serial_number = Entry(main_window, width=80, justify=RIGHT)
        self.entry_serial_number.insert(END, "SERIAL NUMBER REQUIRED")
        self.entry_serial_number.config(state=DISABLED)

        #Entry for CMD
        self.entry_cmd = Entry(main_window, width=160, justify=RIGHT)

        #Style for ttk
        self.style_impact=Style()
        self.style_impact.configure("Kim.TButton",font=("impact", 14))

        #Button section
        self.button_result=ttkButton(main_window, text="Result", command=self.testfn)
        self.button_result.configure(state=DISABLED)
        self.button_run=ttkButton(main_window, text="Run", command=self.testfn2)
        self.button_run.configure(state=DISABLED)
        self.button_cmd=ttkButton(main_window, text="Send")

        #Comboxbox section
        self.combobox_test_run = Combobox(main_window, state = 'readonly', background = 'white', width=80)
        self.combobox_test_run.bind('<<ComboboxSelected>>', self.e_test_chose)
        self.combobox_log = Combobox(main_window, state = 'readonly', background = 'white', width=80)
        self.combobox_log.bind('<<ComboboxSelected>>', self.e_log_chose)

        #Label section
        self.label_unit_code = Label(main_window, text="Unit ID")
        self.label_test_choose = Label(main_window, text="Test")
        self.label_log = Label(main_window, text="Log")
        self.label_test_status = Label(main_window, text="Test status", font=("Copperplate Gothic Bold",18), width=12)
        self.label_test_status_value = Label(main_window, text="N/A", font=("Copperplate Gothic Bold",18), width=8, fg="gray", bg="darkgray", relief=RIDGE, bd=5)


        self._placement_grid_ini()

    def _placement_grid_ini(self):
        self.label_unit_code.grid(row=3, sticky=W, padx=(10,0))
        self.label_test_choose.grid(row=5, sticky=W, padx=(10,0))
        self.label_log.grid(row=9, sticky=W, padx=(10,0))
        self.label_test_status.grid(row=11, column=3, columnspan=2)
        self.label_test_status_value.grid(row=11, column=5, columnspan=2)
        self.entry_serial_number.grid(row=3, column=1, columnspan=6)
        self.entry_cmd.grid(row=62, column=7, columnspan=4)
        self.canvascmd.grid(row=46, column=7, columnspan=30, rowspan=15, sticky=W+E+N+S, padx=5, pady=5)
        self.canvaslog.grid(row=0, column=7, columnspan=30, rowspan=45, sticky=W+E+N+S, padx=5, pady=5)
        self.text_cmd.grid()
        self.button_cmd.grid(row=62, column=12)
        self.button_result.grid(row=62, column=2)
        self.button_run.grid(row=62, column=5)
        #self.combobox_test_run.grid(row=5, column=1, columnspan=6)
        self.combobox_log.grid(row=9, column=1, columnspan=6)
        self.canvas_advancement.grid_propagate(False)
        self.canvas_advancement.grid(row=11, column=1, columnspan=5, rowspan=80)
        self.scrollbar_cmd.grid(row= 46 ,column=99, rowspan=15, ipady=120)
        self.scrollbar_log.grid(row= 0 ,column=99, rowspan=45, ipady=220)
        self.Scrollbar_advancement.grid(row=11,column=6, ipady=260, rowspan=80)

    def test_select(self, arraytest):
        listeCombobox = arraytest
        self.combobox_test_run["values"]=listeCombobox
        self.combobox_test_run.set(listeCombobox[0])

    def list_check_template(self ,list):
        for name in testnamelist:
            testnamelist[name]= Variable()
            checkbutton = Checkbutton(main_window, text=name, variable=testnamelist[name])
            checkbutton.grid(column=1,columnspan=3, sticky=W)

    def e_enter_cmd1(self, event):
        self.enter_cmd()

    def enter_cmd1(self):
        cmd=self.entry_cmd.get()
        self.entry_cmd.delete(0, "end")
        self.text_cmd.config(state=NORMAL)
        self.text_cmd.insert(END, cmd+"\n> ")
        self.text_cmd.see(END)
        self.text_cmd.config(state=DISABLED)

    def testfn2(self):
        self.time_start=time.time()
        self.testrunner.start()
        self.label_test_status_value.config(text="RUNNING",fg="YELLOW")

    def scan_unit(self):
        self.unit_code = tkSimpleDialog.askstring("Input Serial number", "Scan the Serial number")
        if self.unit_code == None:
            showerror("ERROR", "Test fail\nProgram will close")
            self.kill()
        elif self.unit_code == "":
            showinfo("info", "Please input serial number")
            return self.scan_unit()
        else:
            self.entry_serial_number.config(state=NORMAL)
            self.entry_serial_number.delete(0, "end")
            self.entry_serial_number.insert(END, self.unit_code)
            self.entry_serial_number.config(state=DISABLED)
            return self.unit_code

    def _NOT_USED_wait_tester_feedback(self, message="default string for test", message_error="Default message error"):
        if askyesno("Wait for test feedback", message):
            return "yes"
        else:
            return "n"

    def scan_widow(self):
        self.window_open = True
        toplevel = Toplevel()
        toplevel.title("TEST")
        tlabel1 = Label(toplevel, text=ABOUT_TEXT,  width=100)
        tlabel1.pack()
        tlabel2 = Label(toplevel, text=DISCLAIMER,  width=100)

    def testfn(self):
        del self.test_result_not_executed[:]
        del self.test_result_failed[:]
        del self.test_result_passed[:]
        def test_not_executed(test_function):
            self.test_result_not_executed.append(test_function)

        def test_failed(test_function):
            self.test_result_failed.append(test_function)

        def test_passed(test_function):
            self.test_result_passed.append(test_function)

        self.testrunner.visit_test_results(test_not_executed=test_not_executed, test_failed=test_failed, test_passed=test_passed)

        toplevel = Toplevel()
        toplevel.title("Result")
        toplevel.resizable(width=False, height=False)
        Label(toplevel, text=("Date : "), width=40, height=2, anchor=W).grid(row=0, column =0, sticky=W)
        Label(toplevel, text=("Elapsed Time : "), width=40, height=2, anchor=W).grid(row=1, column =0, sticky=W)
        Label(toplevel, text=("Unit ID : "), width=40, height=2, anchor=W).grid(row=2, column =0, sticky=W)
        Label(toplevel, text=("Test passed : "), width=40, height=2, anchor=W).grid(row=3, column =0, sticky=W)
        Label(toplevel, text=("Test not executed : "), width=40, height=2, anchor=W).grid(row=4, column =0, sticky=W)
        Label(toplevel, text=("Test failed : "), width=40, height=2, anchor=W).grid(row=5, column =0, sticky=W)

        nb_test_pass=len(self.test_result_passed)
        nb_test_not_executed=len(self.test_result_not_executed)
        nb_test_fail=len(self.test_result_failed)

        Label(toplevel, text=time.strftime("%x")).grid(row=0, column =1)
        Label(toplevel, text=str(self.time_end-self.time_start)[:5]+" s").grid(row=1, column =1)
        Label(toplevel, text=self.unit_code).grid(row=2, column =1)
        Label(toplevel, text=str(nb_test_pass)).grid(row=3, column =1)
        Label(toplevel, text=str(nb_test_not_executed)).grid(row=4, column =1)
        Label(toplevel, text=str(nb_test_fail)).grid(row=5, column =1)

        Label(toplevel, text=("Test not executed : "),width=40, height=2, anchor=W).grid(row=6, column =0, sticky=W)
        for i in range(0,nb_test_not_executed):
            Label(toplevel, text=self.test_result_not_executed[i], anchor=W).grid(row=7+i, column =0, sticky=W, padx=(10,0))

        Label(toplevel, text=("Test failed : "),width=40, height=2, anchor=W).grid(row=6, column =1, sticky=W)
        for i in range(0,nb_test_fail):
            Label(toplevel, text=self.test_result_failed[i], anchor=W).grid(row=7+i, column =1, sticky=W, padx=(10,0))

    def Temp_name_fn(self):
        self.init_log_thread(os.listdir(self.testrunner.context.LOGS_PATH))

        self.log_selection_setup()

        self.combobox_log['values']=self.listeCombobox
        self.combobox_log.set(self.listeCombobox[-1])

        def test_not_executed(test_function):
            #print(test_function)
            self.test_name.append(test_function)


        self.testrunner.visit_test_results(test_not_executed=test_not_executed, test_failed=test_not_executed)

        self.advancement_test_init(self.test_name)
        self.test_select(("Batch.ini","REV_B.ini","REV_A.ini"))

        self.start_log_thread()

    def init_log_thread(self,file_array):
        #Init log and their repective thread
        #self.threads = {}
        for i in range(0, len(file_array)):
            log_location=os.path.join(self.testrunner.context.LOGS_PATH,file_array[i])
            self.list_log_thread.append(Read_log(log_location, file_array[i]))

    def log_selection_setup(self):
        i=0
        array=""
        for i in range (0,len(self.list_log_thread)):
            array = (array + self.list_log_thread[i].name+" ")
        array = array.strip().split(" ")
        self.listeCombobox = array

    def _bound_to_mousewheel(self, event):
        self.canvas_test_name.focus_force()

    def advancement_test_init(self, test_name):
        self.canvas_test_name= Canvas(self.canvas_advancement, width=500, height=546, bg="gray", highlightthickness=0)
        self.canvas_test_name.config(yscrollcommand=self.Scrollbar_advancement.set)
        self.canvas_test_name.bind('<Enter>', self._bound_to_mousewheel)

        self.canvas_test_name.bind("<MouseWheel>", self.mousewhell_test_status)

        self.Scrollbar_advancement.config(command=self.canvas_test_name.yview)

        self._advancement_setup_test(test_name)
        self.canvas_test_name.grid(row=0, column=0, columnspan=4, rowspan=80, padx=(10,0), pady=(10,0))
        self.canvas_advancement.update_idletasks()
        self.canvas_test_name.config(scrollregion=self.canvas_test_name.bbox(ALL))

    def mousewhell_test_status(self,event):
        self.canvas_test_name.yview_scroll(-1*(event.delta/120), "units")

    def _advancement_setup_test(self, array_test_name):
        self.dict_advancement_status ={}
        frame_test_name = Frame(self.canvas_test_name)
        for i in range(0, len(array_test_name)):
            Label(frame_test_name, wraplength=380, text=array_test_name[i], relief=RIDGE, width=32, pady=3, anchor=W, justify=LEFT, font=("Copperplate Gothic Bold",12), bg="darkgray").grid(row=i, column=0)
            self.dict_advancement_status[array_test_name[i]]=Label(frame_test_name, text="Waiting", relief=RIDGE, width=9, pady=3, height=1, font=("Copperplate Gothic Bold",12), fg="silver", bg="darkgray")
            self.dict_advancement_status[array_test_name[i]].grid(row=i, column=1, sticky=W+E+N+S)
        frame_test_name.pack(fill=BOTH, expand=False)
        self.canvas_test_name.create_window(0,0, anchor = NW, window = frame_test_name)

    def advancement_status_update(self, test_name, test_status):
        if test_status == "Failed":
            color="Red"
        elif test_status == "Passed":
            color="Green"
        elif test_status == "Running":
            color="Yellow"
        else:
            color="Black"
        self.dict_advancement_status[test_name].config(text=test_status, fg=color)

    def _scroll_advancement_test(self,*args):
        self.canvas_test_name.yview(*args)
        #self.canvas_test_status.yview(*args)

    def start_log_thread(self):
        i=0
        for i in range (0,len(self.list_log_thread)):
            self.list_log_thread[i].start()

    def e_test_chose(self, event):
        test_selected=self.combobox_test_run.get()
        pass

    def e_log_chose(self, event):
        log_selected=self.combobox_log.get()
        for i in range (0,len(self.list_log_thread)):
            if log_selected in self.list_log_thread[i].name:
                self.list_log_thread[i].active()
            else:
                self.list_log_thread[i].active(active=False)

    def alert(self):
        showinfo("alert", "Not implemented")

    def kill(self):
        i=0
        for i in range (0,len(self.list_log_thread)):
            self.list_log_thread[i].kill()

            #if self.testrunner.isAlive:
        #self.testrunner.end_section()

        main_window.quit()

    def _menu_about(self):
        toplevel = Toplevel()
        toplevel.title("About")
        toplevel.resizable(width=False, height=False)
        Label(toplevel, text=ABOUT_TEXT,  width=80).pack()

    def menu_setup(self):
        menubar = Menu(main_window)

        menu1 = Menu(menubar, tearoff=0)
        menu1.add_command(label="Open", command=self.alert)
        menu1.add_command(label="Setup", command=self.testrunner_setup)
        menu1.add_command(label="Save as", command=self.alert)
        menu1.add_command(label="Save", command=self.alert)
        menu1.add_separator()
        menu1.add_command(label="History", command=self.alert)
        menu1.add_separator()
        menu1.add_command(label="Exit", command=self.kill)
        menubar.add_cascade(label="File", menu=menu1)

        menu2 = Menu(menubar, tearoff=0)
        menu2.add_command(label="N/I", command=self.alert)
        menu2.add_command(label="N/I", command=self.alert)
        menu2.add_command(label="N/I", command=self.alert)
        menubar.add_cascade(label="Edit", menu=menu2)

        menu3 = Menu(menubar, tearoff=0)
        menu3.add_command(label="N/I", command=self.alert)
        menubar.add_cascade(label="View", menu=menu3)

        menu4 = Menu(menubar, tearoff=0)
        menu4.add_command(label="About", command=self._menu_about)
        menubar.add_cascade(label="Help", menu=menu4)

        menu5 = Menu(menubar, tearoff=0)
        menu5.add_command(label="Feedback", command=self.wait_tester_feedback)
        menu5.add_command(label="Scan Unit", command=self.scan_unit)
        menu5.add_command(label="testme", command=self.testme)
        menubar.add_cascade(label="Test", menu=menu5)


        main_window.config(menu=menubar)


class Read_log(Thread):

    def __init__(self, file, name):
        Thread.__init__(self)
        self.file = file
        self.flag=True
        self.flag_active=False
        self.name = name
        self.scrollbar_log = Scrollbar(main_window)
        self.canvaslog = Canvas(main_window,width=1000, height=400, bg="grey")
        self.text_log= Text(self.canvaslog, wrap=WORD, yscrollcommand=self.scrollbar_log.set, width=130, height=30, bd=6)
        self.text_log.insert(END, " ")
        time.sleep(0.5)
        self.text_log.delete("1.0", END)
        self.text_log.config(state=DISABLED)
        self.canvaslog.grid(row=0, column=7, columnspan=30, rowspan=45, sticky=W+E+N+S, padx=5, pady=5)
        self.text_log.grid()
        self.scrollbar_log.grid(row= 0 ,column=99, rowspan=45, ipady=220)
        self.scrollbar_log.config(command=self.text_log.yview)

    def run(self):
        self.init_logfile(self.read_file(self.file))
        try:
            while self.flag:
                if self.flag_active:
                    lines=[]
                    with open(self.file, 'r') as f:
                        readed = f.read().strip().split("\n")
                        for i in range(0,len(readed)):
                            lines.append(readed[i])
                    old_log=self.retrieve_input(self.text_log).strip().split("\n")
                    #print("old : "+str(len(old_log))+" line : "+str(len(lines)))
                    self.update_logfile(self.compare_log(old_log, lines))
                time.sleep(0.5)
        except Exception:
            pass

    def update_logfile(self, arraytxt):
        if arraytxt != None:
            self.text_log.config(state=NORMAL)
            for i in range (0,len(arraytxt)):
                self.text_log.insert(END, "\n"+arraytxt[i])
                self.text_log.see(END)
            self.text_log.config(state=DISABLED)

    def init_logfile(self, arraytxt):
        text="\n".join(arraytxt)
        self.text_log.config(state=NORMAL)
        self.text_log.insert(END, text)
        self.text_log.config(state=DISABLED)

    def compare_log(self, filea, fileb):
        if len(filea) <= len(fileb):
            i=0
            missing_data =[]
            num_missing = len(fileb) - len(filea)
            for i in range (0,num_missing):
                missing_data.append(fileb[len(filea)+i])
            return missing_data

    def retrieve_input(self, log):
        return log.get("1.0",'end-1c')

    def read_file(self, file):
        lines=[]
        with open(file, 'r') as f:
            readed = f.read().strip().split("\n")
            for i in range(0,len(readed)):
                lines.append(readed[i])
        return lines

    def kill(self):
        self.flag = False
        print ("killed")

    def active(self, active=True):
        if active:
            self.flag_active =True
            self.canvaslog.grid()
            self.text_log.grid()
            self.scrollbar_log.grid()
        else :
            self.flag_active =False
            self.canvaslog.grid_remove()
            self.text_log.grid_remove()
            self.scrollbar_log.grid_remove()

def main(package_path, **kwargs):
    try :
        t = gui(package_path, **kwargs)
        t.menu_setup()
        t.setup_interface()
        print("in")
        main_window.mainloop()
        print ("out")
        time.sleep(1)
        t.kill()
    except KeyboardInterrupt:
        t.kill()
    except Exception as e:
        #t.kill()
        #log_thread.kill()
        print(e)
        raise

if __name__ == '__main__':
    main()
