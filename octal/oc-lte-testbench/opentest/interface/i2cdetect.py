from opentest.interface import comserial, ssh
from nute import utils
import os
import click



TEST_SUCCESS_STRING = "I2CDetect test pass"
TEST_FAILURE_STRING = "I2CDetect test fail"
HEADER_CHARS_EXPECTED = ['0 ', '1 ', '2 ', '3 ', '4 ', '5 ', '6 ', '7 ', '8 ', '9 ']

TARGET_STRING = "root@"

@click.group(help="This file contains all function use for ATE")
def group_entry():
    pass
##region find(serverport, url, path ,expected_addr)
@group_entry.command('find', help="find i2c file at location")
@click.argument('serverport')
@click.argument('url')
@click.argument('path')
@click.argument('expected_addr', nargs=-1)
def _cmd_find(*args, **kwargs):
    detect(*args, **kwargs)

@utils.capture_print
def find(serverport, url, path ,expected_addr):
    missing = ""
    cmd = "ls " + path
    found = ssh.execute(port = serverport, url=url, cmd=cmd, capture_print=True)
    for address in expected_addr:
        if address not in found:
            missing = missing + address + " "
    print missing

##endregion find(serverport, url, path ,expected_addr)
def cleanI2CDetect(string):
    #Remove command sent and first column
    lines = string.split('\n')
    index = 0
    for index in range(0, len(lines)):
        #Remove first 3 chars of each line
        if TARGET_STRING in lines[index] or 'i2cdetect' in lines[index] or isI2CDetectHeaderLine(lines[index]):
            lines[index] = "\n"
        lines[index] = lines[index][3:]

    return '\n'.join(lines)

def isI2CDetectHeaderLine(line):
    isHeader = True
    for char in HEADER_CHARS_EXPECTED:
        if char not in line:
            isHeader = False

    return isHeader

def formatI2CDetectCommand(bus_number, addr):
    #i.e. : bus_number =3, addr = 0x57
    #i2cdetect will scan on bus 3 range 0x57 to 0x57
    #i2cdetect -y -r 3 0x57 0x57
    return "i2cdetect -y -r " + str(bus_number) + " " + str(addr) + " " + str(addr) + "\x0d"


@group_entry.command('detect', help="")
@click.argument('comport')
@click.argument('bus_number')
@click.argument('serverport')
@click.argument('expected_addr', nargs=-1)
def _cmd_detect(*args, **kwargs):
    detect(*args, **kwargs)

@utils.capture_print
def detect(comport, bus_number, serverport, expected_addr):
    failed_test =""
    test_pass = True
    for addr in expected_addr:
        addr = addr.lower()
        command = formatI2CDetectCommand(bus_number, addr)
        result = comserial.target(serverport,comport, 3, command, TARGET_STRING, capture_print=True)


        result = cleanI2CDetect(result)
        #Remove 0x for comparison since the return does not contain them
        #addr = addr.strip("0x")
        if addr.strip("0x") not in result and "UU" not in result:
            test_pass = False
            failed_test = (failed_test + addr+", ")
    if test_pass:
        print TEST_SUCCESS_STRING
    else:
        print (TEST_FAILURE_STRING +" : "+failed_test)

if __name__ == "__main__":
    # This block pauses the command line when bad arguments are passed or when the
    # main exits early.
    # This is needed when the command line exits after execution, as it gives us
    # time to see the error.
    try:
        group_entry()
    except SystemExit as e:
        os.system("pause")
        raise
