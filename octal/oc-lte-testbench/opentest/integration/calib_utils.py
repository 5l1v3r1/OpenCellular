import ConfigParser
import logging
import csv
import numpy as np
from scipy import interpolate
from nute import utils

##region Calibration table

class Generic1DCalibTable(object):
    def __init__(self):
        self.measures = []
        self.function = None

    def add_measure(self, x, y):
        self.measures.append((x,y))
        self.measures.sort(key=lambda tup: tup[0])

    def generate_interpolation_function(self, **kwargs):
        self.np_array = np.array(self.measures)
        self.function = interpolate.interp1d(self.np_array[:,0], self.np_array[:,1], **kwargs)

    def interpolate(self, x):
        if not self.function:
            self.generate_interpolation_function()

        return self.function(x)

    def interpolate_range(self, x_array):
        return [self.interpolate(x) for x in x_array]

    def interpolate_step(self, x_step, include_end=True):
        start = self.freq_start()
        stop = self.freq_stop()
        if include_end:
            stop = stop + x_step

        return self.interpolate_range(np.arange(start, stop, x_step))

    def interpolate_linspace(self, num_points):
        start = self.freq_start()
        stop = self.freq_stop()

        return self.interpolate_range(np.linspace(start, stop, num_points))

    def freq_start(self):
        return self.measures[0][0]

    def freq_stop(self):
        return self.measures[-1][0]

class LTECalibTable(object):
    def __init__(self):
        self.rows = []

    def add_row(self, row):
        self.rows = self.rows + [row]

    def format(self):
        rows = [row.format() for row in self.rows]
        return '\n'.join(rows)

    def save_to_file(self, file_name):
        with open(file_name, 'wb') as f:
            f.write(self.format())

    def save(self, bandwidth, tx):
        self.save_to_file(self.file_name(bandwidth, tx))

    def load(self, bandwidth, tx):
        self.load_from_file(self.file_name(bandwidth, tx))

    def load_from_file(self, file_name):
        with open(file_name, 'r') as f:
            for line in f.read().splitlines():
                row = CalibRow()
                try:
                    row.values = utils.safe_eval(line)
                except:
                    row.values = line.split(' ')
                if not isinstance(row.values, list):
                    row.values = [row.values]
                self.add_row(row)

    def file_name(self, bandwidth, tx):
        return self.file_format() % (bandwidth, tx+1)

    def file_format(self):
        raise NotImplementedError

    def get_attens(self):
        row = self.rows[self.attens_row()]
        return [float(val) for val in row.values]

    def set_attens(self, freq_range, attens):
        self.rows[self.freq_row()] = FreqRow(freq_range)
        self.rows[self.attens_row()] = ArrayRow(attens)

    def get_freq_range(self):
        row = self.rows[self.freq_row()]
        if len(row.values) == 1:
            row.values = utils.safe_eval(row.values[0])
        if len(row.values) == 3:
            start = int(row.values[0])
            stop = int(row.values[2])
            step = int(row.values[1])

        if len(row.values) == 3 and step < start and step < stop:
            return range(start, stop + step, step)
        else:
            return row.values

    def freq_row(self):
        raise NotImplementedError

    def attens_row(self):
        raise NotImplementedError

    def interpolate_table(self, affecting_attens=None, this_to_affecting_ratio=1):
        current_freq_range = self.get_freq_range()
        current_attens = self.get_attens()

        new_attens = []
        affing_attens = affecting_attens
        last_point = None
        first_freq = None
        for freq, atten in zip(current_freq_range, current_attens):
            if last_point is not None:
                last_freq = last_point[0]
                freq_diff = freq - last_freq
                if affing_attens is None:
                    new_attens = new_attens + interpolate_atten(last_point, (freq, atten))
                else:
                    first_index = last_freq-first_freq
                    interpolated = interpolate_atten_with_affecting_atten(last_point, (freq, atten), affing_attens[first_index:first_index+freq_diff+1], this_to_affecting_ratio)
                    # print(interpolated)
                    new_attens = new_attens + interpolated

                new_attens = new_attens + [atten]

            else:
                first_freq = freq
                new_attens.append(atten)
            last_point = (freq, atten)

        self.set_attens(range(first_freq, freq+1), new_attens)
        return new_attens





class LTEBBCalibTable(LTECalibTable):
    def __init__(self):
        LTECalibTable.__init__(self)

    def set_values(self, freq_range, temp, attens, freqs_as_array=False):
        if freqs_as_array:
            self.add_row(ValueRow(freq_range))
        else:
            self.add_row(FreqRow(freq_range))
        self.add_row(IntegerArrayRow(attens))
        return self

    def file_format(self):
        return 'bbtxatten_b3_%d_ant%d.cal'

    def freq_row(self):
        return 0

    def attens_row(self):
        return 2

class LTETXCalibTable(LTECalibTable):
    def __init__(self):
        LTECalibTable.__init__(self)

    def set_values(self, freq_range, pwr_range, temp, attens, freqs_as_array=False):
        if freqs_as_array:
            self.add_row(ValueRow(freq_range))
        else:
            self.add_row(FreqRow(freq_range))
        self.add_row(PowerRow(pwr_range))
        self.add_row(IntegerValueRow(temp))
        self.add_row(IntegerArrayRow(attens))
        return self

    def file_format(self):
        return 'fetxatten_b3_%d_ant%d.cal'

    def freq_row(self):
        return 0

    def attens_row(self):
        return 3

class LTEFBCalibTable(LTECalibTable):
    def __init__(self):
        LTECalibTable.__init__(self)

    def set_values(self, freq_range, pwr_range, temp, attens, freqs_as_array=False):
        if freqs_as_array:
            self.add_row(ValueRow(freq_range))
        else:
            self.add_row(FreqRow(freq_range))
        self.add_row(PowerRow(pwr_range))
        self.add_row(IntegerArrayRow(attens))
        return self

    def file_format(self):
        return 'fefbatten_b3_%d_ant%d.cal'

    def freq_row(self):
        return 0

    def attens_row(self):
        return 3

class LTEFERXCalibTable(LTECalibTable):
    def __init__(self):
        LTECalibTable.__init__(self)

    def set_values(self, freq_range, pwr_range, temp, attens):
        self.add_row(FreqRow(freq_range))
        self.add_row(PowerRow(pwr_range))
        self.add_row(IntegerValueRow(temp))
        self.add_row(IntegerArrayRow(attens))
        return self

    def file_format(self):
        return 'ferxatten_b3_%d_ant%d.cal'

    def freq_row(self):
        return 0

    def attens_row(self):
        return 3

class LTEBBRXCalibTable(LTECalibTable):
    def __init__(self):
        LTECalibTable.__init__(self)

    def set_values(self, freq_range, attens):
        self.add_row(FreqRow(freq_range))
        self.add_row(IntegerArrayRow(attens))
        return self

    def file_format(self):
        return 'bbrxatten_b3_%d_ant%d.cal'

    def freq_row(self):
        return 0

    def attens_row(self):
        return 1

class CalibRow(object):
    def __init__(self):
        self.values = []

    def format(self):
        strings = [str(v) for v in self.values]
        return ' '.join(strings)

class RangeRow(CalibRow):
    def __init__(self, _range):
        self.set_range(_range)
        self.range = _range

    def set_range(self, _range):
        if bool(_range):
            start = _range[0]
            stop = _range[-1]
        try:
            step = _range[1] - _range[0]
        except:
            step = 1
        self.values = [start, step, stop]

class FreqRow(RangeRow):
    pass

class PowerRow(RangeRow):
    pass

class IntegerValueRow(CalibRow):
    def __init__(self, value):
        self.values = [round(value)]

    def format(self):
        strings = ["%d" % v for v in self.values]
        return ' '.join(strings)

class ValueRow(CalibRow):
    def __init__(self, value):
        self.values = [value]

class IntegerArrayRow(CalibRow):
    def __init__(self, values):
        self.values = [round(float(value)) for value in values]

    def format(self):
        strings = ["%d" % v for v in self.values]
        return ' '.join(strings)

class ArrayRow(CalibRow):
    def __init__(self, values):
        self.values = values


def interpolate_atten_with_affecting_atten(point_a, point_b, affecting_atten_including_ends, affected_to_affecting_ratio):
    affing_attens = affecting_atten_including_ends
    affing_start = affing_attens[0]
    affing_end  = affing_attens[-1]
    ratio = affected_to_affecting_ratio

    affing_diff = affing_end - affing_start
    _point_b = (point_b[0], point_b[1] - (affing_diff*ratio))


    affing_diff_attens = [affing_atten - affing_start for affing_atten in affing_attens[1:-1]]
    affed_attens = interpolate_atten(point_a, _point_b)
    affed_attens = [affed_atten + (affing_diff_atten*ratio) for affed_atten, affing_diff_atten in zip(affed_attens, affing_diff_attens)]
    return affed_attens

def interpolate_atten(point_a, point_b, resolution_divider=1):
    freqs = (point_a[0], point_b[0])
    attens = (point_a[1], point_b[1])

    def lin_fn(freq):
        percent = float(freq-freqs[0])/float(freqs[1]-freqs[0])
        atten_diff = attens[1] - attens[0]
        return (atten_diff*percent) + attens[0]

    interpolated_attens = []

    for freq in range(freqs[0] + 1, freqs[1]):
        atten = lin_fn(freq)
        atten = round_with_divider_resolution(atten, resolution_divider)
        interpolated_attens.append(atten)

    return interpolated_attens

def round_with_divider_resolution(number, divider):
    return round(number*divider)/divider

##endregion

class PathLosses(object):
    def __init__(self):
        self.losses = {}

    def get_loss(self, patha, pathb):
        key = self.get_key(patha, pathb)
        return self.get_loss_key(key)

    def get_loss_key(self, key):
        if key in self.losses:
            return self.losses[key]
        else:
            return None

    def get_key(self, patha, pathb):
        return (patha, pathb)

    def set_losses(self, paths, losses):
        for path, loss in zip(paths, losses):
            self.set_loss(path[0], path[1], loss)

    def set_loss(self, patha, pathb, loss):
        self._add_one_way_loss(patha, pathb, loss)
        self._add_one_way_loss(pathb, patha, loss)

    def _add_one_way_loss(self, patha, pathb, loss):
        self.losses[(patha, pathb)] = float(loss)

    def save_to_file(self, file_path):
        config = ConfigParser.SafeConfigParser()
        config.optionxform = str
        for paths, loss in self.losses.iteritems():
            section, option = self._get_config_section_and_name(config, paths)
            if section is not None:
                config.set(section, option, str(loss))

        with open(file_path, 'w') as config_file:
            config.write(config_file)

    def load_from_file(self, file_path):
        config = ConfigParser.SafeConfigParser()
        config.optionxform = str
        config.read(file_path)
        for section in config.sections():
            for name, value in config.items(section):
                self.set_loss(section, name, value)


    def _get_config_section_and_name(self, config, paths):
        path_section = paths[0]
        path_name = paths[1]
        if config.has_section(path_name) and config.has_option(path_name, path_section):
            return None, None
        elif config.has_section(path_section):
            if config.has_option(path_section, path_name):
                #Already exists, return none
                return None, None
            else:
                pass
        elif config.has_section(path_name):
            #Invert
            return self._get_config_section_and_name(config, (path_name, path_section))
        else:
            #Both sections do not exist, no inversion and create sections
            config.add_section(path_section)

        return path_section, path_name

class SwitchMatrix():
    def __init__(self, logger=None):
        self.switches = {}
        self.graph = {}
        if logger is not None:
            self.logger = logger
        else:
            self.logger = logging.getLogger('switch_matrix')

    def parse_ini_file(self, file_path):
        with open(file_path) as f:
            self.parse_ini_string(f.read())

    def parse_ini_string(self, string):
        import ConfigParser
        import StringIO
        buf = StringIO.StringIO(string)
        config = ConfigParser.SafeConfigParser()
        config.optionxform = str
        config.readfp(buf)

        for section in config.sections():
            switch_name = section
            switch = SimpleSwitch(switch_name)
            for name, value in config.items(section):
                if name.upper() != 'COM':
                    switch.add_port(name)

            switch = self.update_switch(switch)

            for name, value in config.items(section):
                self.add_new_link(switch.get_full_port_name(name), value)
        self.add_missing_switches_nodes()

    def add_missing_switches_nodes(self):
        """
        Loops through the whole graphs and searches for switch's ports that were added but that are not linked to the switch COM.
        """
        for node, value in self.graph.iteritems():
            switch_name = self.get_switch_from_port_name(node)
            port_name = self.get_port_from_full_port_name(node)
            if switch_name:
                switch = self.switches[switch_name]
                switch.add_port(port_name)
                self.update_switch(switch)


    def update_switch(self, switch):
        self.combine_graphs(switch.node)
        self.switches[switch.name] = switch
        return switch

    def combine_graphs(self, graph_to_append):
        for node, value in graph_to_append.iteritems():
            if node not in self.graph:
                self.graph[node] = value
            else:
                self.graph[node] = self.combine_tuple_no_duplicate(self.graph[node], value)

    def combine_tuple_no_duplicate(self, tuple1, tuple2):
        return tuple1 + tuple(set(tuple2) - set(tuple1))

    def add_new_link(self, a, b):
        switch_a = self.get_switch_from_port_name(a)
        switch_b = self.get_switch_from_port_name(b)

        if switch_a == switch_b:
            if switch_a == None:
                raise ValueError("Trying to link two external nodes that do not pass through the switch.")
            else:
                raise ValueError("Trying to link a switch with itself")

        self._add_half_link(a,b)
        self._add_half_link(b,a)

    def _add_half_link(self, a, b):
        if a in self.graph:
            self.graph[a] = self.graph[a] + (b,)
        else:
            self.graph[a] = (b,)

    def find_shortest_path(self, start, end, path=[]):
        path = path + [start]
        graph = self.get_graph_for_path(path)
        if start == end:
            return path

        if not graph.has_key(start):
            return None
        self.logger.debug(start)
        shortest = None
        for node in graph[start]:
            if node not in path:
                newpath = self.find_shortest_path(node, end, path)
                if newpath:
                    if not shortest or len(newpath) < len(shortest):
                        shortest = newpath
        return shortest

    def get_graph_for_path(self, path):
        graph = self.graph.copy()
        previous_switch = 'some random,impossible switch name'
        for node in path:
            switch = self.get_switch_from_port_name(node)
            port = self.get_port_from_full_port_name(node)
            if port == "COM" and switch == previous_switch:
                #Remove links from x.COM to x.PORTy
                self.remove_links_to_switch_from_node(node, switch, graph)
            previous_switch = switch
        return graph


    def remove_links_to_switch_from_node(self, node, switch_name, graph):
        new_tuple = ()
        for old_value in graph[node]:
            switch = self.get_switch_from_port_name(old_value)
            if switch != switch_name:
                new_tuple = new_tuple + (old_value,)

        graph[node] = new_tuple

    def get_actions_for_path(self, start, end):
        #Start with None action (no action required)
        #All switches present
        actions = dict.fromkeys(self.switches)
        self.logger.debug("Searching path")
        shortest_path = self.find_shortest_path(start, end)
        if shortest_path == None:
            message = "Path does not exists"
            if start not in self.graph:
                message = message + ": start point %s does not exists" % start
            if end not in self.graph:
                message = message + ": end point %s does not exists" % end
            raise ValueError(message)

        previous_switch = ''
        current_switch = None
        previous_node = None
        for node in shortest_path:
            current_switch = self.get_switch_from_port_name(node)
            if current_switch == previous_switch:
                #Internal switch path: action required
                actions[current_switch] = self.get_switch_action(current_switch, node, previous_node)

            previous_switch = current_switch
            previous_node = node


        return actions

    def __str__(self):
        string = []
        for key, value in self.graph.iteritems():
            string.append("%-10s -> %s" %(key, str(value)))
        return '\n'.join(sorted(string))

    def get_switch_action(self, switch_name, node, previous_node):
        switch_object = self.switches[switch_name]
        try:
            action = switch_object.get_switch_action(node)
        except ValueError:
            action = switch_object.get_switch_action(previous_node)

        return action


    def get_switch_from_port_name(self, port_name):
        return self.get_split_name(port_name, 0)

    def get_port_from_full_port_name(self, port_name):
        return self.get_split_name(port_name, 1)

    def get_split_name(self, port_name, split_index):
        #Switch port A.PORT1
        #Other port SPECTRUM (no dot)
        split_str = port_name.split('.')
        if len(split_str) < 2:
            #Not a switch port
            return None
        else:
            return split_str[split_index]

    def get_switches(self):
        for switch in self.switches:
            yield switch

    def get_numb_switch(self):
        return len(self.switches)

    def get_name_port(self):
        for key, value in self.graph.iteritems():
            if self.get_port_from_full_port_name(key) == None:
                yield key


class SimpleSwitch():
    def __init__(self, name, *ports):
        self.name = name
        self.com_name = self.name + '.COM'
        self.node = {self.com_name: ()}

    def add_port(self, port):
        new_port = self.get_full_port_name(port)
        if new_port not in self.node:
            unsorted = self.node[self.com_name] + (new_port,)
            self.node[self.com_name] = tuple(sorted(unsorted))
            self.node[new_port] = (self.com_name,)

    def add_ports(self, *ports):
        for port in ports:
            self.add_port(port)

    def get_switch_action(self, port):
        return self.node[self.com_name].index(port)

    def get_full_port_name(self, port):
        return self.name + '.' + port
