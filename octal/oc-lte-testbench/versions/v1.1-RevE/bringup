#!/bin/sh

if [ -f /tmp/system.conf ]; then
source /tmp/system.conf
elif [ -f /mnt/app/ubootenv ] ; then
source /mnt/app/ubootenv
fi

if [ -z "$SYNCBY" ]; then SYNCBY=internal; fi

if [ "$SYNCBY" == "gps" ];then       
	 echo "[$0] Setting GPIO for GPS"
#	 oct-linux-csr GPIO_BIT_CFG5 0x0
#	 oct-linux-csr GPIO_BIT_CFG4 0x0
#	 oct-linux-csr MIO_PTP_PHY_1PPS_IN 0x5
fi
acscli_set() {
    if [ -n "$1" -a -n "$2" ] ; then
        acscli << EOF
set $1 $2
quit
EOF
    fi
}

acscli_get() {
    if [ -n "$1" ] ; then
        acscli << EOF
get $1
quit
EOF
    fi
}

## In this section, running in PLTd or E2E determines how SW is loaded
## in pltD mode, we will prepare the environment with testvectors 
## and pltd in a mode to set lsmD in test mode.
## In E2E mode, we will prepare the environement to configure the smallcell
## as an element of a end to end network.

# Defualt to E2E mode is MODE is not declared
if [ -z $MODE ];then MODE=e2e;fi

if [ "$MODE" == "pltd" ];then
if [ -z $MODE_TEST ];then MODE_TEST=dl;fi
# The Duplex mode for E2E is setup in S90STARTAPP, while setting the LFMSOFT file
### Extract DUPLEX MODE of stack
## ** Should cross verify with RF EEPROM band indicator and DSP revision

if [ -e /bin/svnversion ];then
    DUPLEXMODE=`cat /bin/svnversion |awk '/Product/{print $2}'`
fi
if [ -z $DUPLEXMODE ];then DUPLEXMODE=FDD;fi

echo "[$0] : START Override DSP RF Interface parameters in "$DUPLEXMODE" mode"
if [ -f /usr/bin/updatephyrfparams.sh ]; then
    /usr/bin/updatephyrfparams.sh ${DUPLEXMODE} WRDDRCFG
    echo "[$0] : DONE Override DSP RF Interface parameters"
else
    echo "[$0] : S13swselect did not correctly retreive updatephyrfparams.sh by $CFGLOADBY"
fi



echo "[$0] Preparing platform to run $MODE_TEST PLTD mode..."
./usr/bin/dl_pltd.sh 0

  if [ "$MODE_TEST" == "ul" ];then
    ./usr/bin/ul_pltd.sh 0
	setgpio 0 0 # Light up top LED
  else
	setgpio 0 6 # Light up bottom LED
  fi
  echo "[$0] Done setting $MODE_TEST PLTD mode."
  sleep 1
else ## MODE != pltd


  echo "[BRINGUP] Bringing up S1 link [START]"

  renice -n 0 `ps |grep -m 1 core0app |awk '{ print ($1)}'`
  renice -n 0 `ps |grep -m 1 core1app |awk '{ print ($1)}'`
  echo "[BRINGUP] Renice done, Sleep 4 before we Dimark start when acsenable is set"
  sleep 4

  if [ "$ACSENABLE" == "1" -o "$IPSECEN" == "1" ];then
            cd /Dimark_Client
            ./start.sh
            cd /
  fi

  if [ "$IPSECEN" == "1" ];then
	sleep 8

	acscli_set IPSEC_PROFILE_RemoteEndpoints[1] ${SECGWIP}
	acscli_set IPSEC_FILTER_DestIP[1] ${MMEIP}
	acscli_set IPSEC_FILTER_DestMask[1] ${MMEIPMASK}
	acscli_set IPSEC_FILTER_SourceIP[1] ${IPSEC181_SOURCEIP}
	acscli_set IPSEC_FILTER_SourceMask[1] ${IPSEC181_SOURCEMASK}
	acscli_set IPSEC_FILTER_Profile[1] Device.IPsec.Profile.1.
	acscli_set IPSEC_FILTER_ProcessingChoice[1] Protect
	acscli_set IPSEC_PROFILE_IKEv2AllowedEncryptionAlgorithms[1] ${IPSEC181_IKEENC}
	acscli_set IPSEC_PROFILE_IKEv2AllowedIntegrityAlgorithms[1] ${IPSEC181_IKEINTEG}
	acscli_set IPSEC_PROFILE_IKEv2AllowedDiffieHellmanGroupTransforms[1] ${IPSEC181_IKEDH}
	acscli_set IPSEC_FILTER_Enable[1] 1

	#sleep 4
	#acscli_get IPSEC_FILTER_Status[1]
  fi

    sleep 3
    echo "[$0] Bringing up S1 link [DONE]"

    # Assure root access to webUI.
    chown root:root -R /var/www

  version
  DSPSTATECHECK.sh

  if [ "$IPSECEN" == "1" ];then
  ipsec statusall
  fi

  ## Monitor Cell State.  Exit after $FAPENABLECOUNT is -lt 0
  echo -n "[$0] Checking CELL STATE "

  while [[ 1 ]];do
	if grep "ERROR: DSP Downloading Error" /var/log/core0 1>/dev/null 2>&1 ; then
		echo
		echo "[$0] ERROR: DSP Downloading Error"
		exit 1
	fi;
	echo -n ". "
	sleep 5
	ENB_STATE_MSG=`cat /var/log/core0 | grep "S_RRC_CELL_STATE_IND"`
	ENB_STATE=`echo $ENB_STATE_MSG | awk -F"(" '/state/{print $4}' | awk -F")" '{print $1}'`
	if [ -z $ENB_STATE ];then ENB_STATE=UNKNOWN;fi
	if [ $ENB_STATE == "enabled" ];then
	    echo
	    echo "[$0] CELL is in ENABLE STATE ...... [DONE - $FAPENABLECOUNT]"
	    break
	fi
        if [ -z $FAPENABLECOUNT ];then FAPENABLECOUNT=16;fi
	if [ $FAPENABLECOUNT -lt 0 ];then
	    echo
	    echo "[$0] CELL is in $ENB_STATE STATE ...... [DONE]"
	    toggle 1 0&
	    exit 1
	fi
	let FAPENABLECOUNT=$FAPENABLECOUNT-1
  done

  sh /sbin/rev28fix.sh
  sleep 1
  
  ## This section is required in the we need to generate PPS
  if [ "$SYNCBY" == "internal" ];then
	echo "[$0] Setting memory for internal"
     oct-linux-memory -w 4 0x00010F0000868110 1
  fi
  echo "[$0] Enable synchronization by $SYNCBY"

fi ## pltd or e2e mode selection

###  Specific to TIP board
##
if [ "$TIP" == "1" ];then
	echo "Setting up receive path for TIP board"
	oncpu 0 /usr/bin/cn_rfdriver adi << eof
w 0x04 0x03 w 0x10 0xdc q
eof
sleep 1
fi
##

###  Set half-band filter for 5MHz
##
if [ "$BW" == "5" ];then
	oncpu 0 /usr/bin/cn_rfdriver << eof
w 0x02 0xde q
eof
sleep 1
fi
##

### Create/Add version file for WebUI
##
echo "<font size=1><tt>" > /tmp/.ver
dmesg|head -n 4 | grep -v CVMSEG | sed -e "s/:/ /"  | awk '{print $1" "$2":"$3" <br>"}'         >> /tmp/.ver
STACK_version=`version | grep STACK | awk '{print $6}'`
DSP_version=`version   | grep DSP   | awk '{print $5}'`
echo "${DUPLEXMODE} STACK Revision: ${STACK_version} <br>" >> /tmp/.ver
echo "DSP Revision: ${DSP_version}</tr>"                   >> /tmp/.ver


echo "[$0] SmallCell in $MODE mode"

echo "Start fe-manager"
if [ -f /bin/fe-manager ] ; then
    fe-manager &
else
    echo "WARNING: Failed finding application /bin/fe-manager!"
fi